<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Architecture Project Planner</title>
  <style>
    *,*::before,*::after{box-sizing:border-box;}
    :root{--sidebar-width:600px;--day-width:32px;--row-height:54px;--primary:#3056d3;--surface:#fff;--surface-alt:#f2f4f9;--border:#d6dbe7;--text:#1f2937;--text-muted:#4b5563;--top-offset:1rem;--header-vertical-offset:5rem;--sidebar-header-height:0px;--header-band-height:0rem;--body-offset: 10rem; --task-header-height:4.5rem;--vertical-header-offset:15.55rem; --timeline-header-height:4.5rem;--task-header-top:calc(var(--top-offset) + var(--content-offset));--timeline-header-top:calc(var(--top-offset) + var(--content-offset));--gantt-header-height:0px;--task-scroll-height:calc(100vh - 100px);--gantt-scroll-height:calc(100vh - 100px);--content-offset:0.88rem;}
    html{height:100%;overflow:hidden;}
    body{margin:0;font-family:"Inter","Segoe UI",-apple-system,BlinkMacSystemFont,sans-serif;background:#eef1f7;color:var(--text);min-height:100vh;height:100vh;overflow:hidden;display:flex;flex-direction:column;font-size:.94rem;}
    h1,h2,h3{margin:0;}
    button{border:0;background:var(--primary);color:#fff;border-radius:8px;padding:.5rem 1rem;font-size:.95rem;font-weight:600;cursor:pointer;transition:transform .15s ease,box-shadow .15s ease;}
    button:disabled{opacity:.4;cursor:not-allowed;}
    button:not(:disabled):hover{transform:translateY(-1px);box-shadow:0 10px 18px rgba(48,86,211,.16);}
    input,textarea{font:inherit;border-radius:6px;border:1px solid var(--border);padding:.35rem .5rem;width:100%;background:#fff;color:inherit;}
    input:focus,textarea:focus{outline:2px solid rgba(48,86,211,.25);border-color:transparent;}
    textarea{resize:vertical;min-height:96px;}
    .top-bar{display:flex;flex-direction:column;gap:1rem;padding:1.1rem 1.75rem 1rem;background:#fff;border-bottom:1px solid var(--border);box-shadow:0 2px 8px rgba(31,45,61,.08);position:sticky;top:0;z-index:5;}
    .top-bar-row{display:flex;align-items:center;gap:1.25rem;flex-wrap:wrap;justify-content:flex-start;width:100%;}
    .top-bar-row.heading-row{justify-content:flex-start;}
    .top-bar-row.primary-actions-row{justify-content:flex-start;}
    .top-bar-row.legend-row{justify-content:flex-end;}
    .top-bar-row.secondary-actions-row{justify-content:space-between;}
    .project-heading{display:flex;align-items:center;gap:1.1rem;flex-wrap:wrap;justify-content:flex-start;}
    .project-heading h1{font-size:1.45rem;font-weight:700;margin:0;}
    .top-bar-sidebar-actions{display:flex;align-items:center;gap:.6rem;flex-wrap:wrap;justify-content:flex-start;}
    .top-bar .top-bar-sidebar-actions button{flex:0 0 auto;min-width:0;}
    .top-bar .button-row{display:flex;align-items:center;gap:.75rem;flex-wrap:wrap;}
    .top-bar .button-row .secondary{background:var(--surface-alt);color:var(--text);border:1px solid var(--border);box-shadow:none;}
    .top-bar .button-row .secondary:hover{transform:none;color:var(--primary);border-color:var(--primary);}
    .legend{display:flex;flex-wrap:wrap;gap:.85rem;align-items:center;}
    .legend-item{display:flex;align-items:center;gap:.45rem;font-size:.78rem;color:var(--text-muted);}
    .legend-swatch{width:16px;height:16px;border-radius:6px;box-shadow:0 0 0 1px rgba(15,23,42,.1);}
    .app{display:flex;flex:1;min-height:0;}
    .sidebar{width:var(--sidebar-width);flex:0 0 var(--sidebar-width);background:var(--surface);border-right:1px solid var(--border);display:flex;flex-direction:column;position:sticky;left:0;z-index:6;min-height:0;}
    .sidebar-actions{display:flex;gap:.6rem;flex-wrap:wrap;}
    .sidebar-actions button{flex:1 0 48%;min-width:0;}
    .sidebar-actions .icon-btn{flex:0 0 auto;width:42px;padding:.45rem;background:var(--surface-alt);color:var(--text);border:1px solid var(--border);box-shadow:none;font-size:1rem;line-height:1;border-radius:8px;}
    .sidebar-actions .icon-btn:hover{transform:none;color:var(--primary);border-color:var(--primary);}
    .sidebar-actions .secondary{background:var(--surface-alt);color:var(--text);border:1px solid var(--border);box-shadow:none;}
    .sidebar-actions .secondary:hover{transform:none;color:var(--primary);border-color:var(--primary);}
    .task-list-header,
    .task-row{display:grid;grid-template-columns:50px 120px 110px 110px 70px 90px;column-gap:0.6px;align-items:center;}
    .task-list-header{padding:0 1rem;font-size:.65rem;font-weight:600;text-transform:uppercase;letter-spacing:.05em;color:var(--text-muted);background:rgba(48,86,211,.08);position:sticky;top:var(--task-header-top, calc(var(--top-offset) + var(--content-offset)));z-index:6;align-items:center;border-top:1px solid var(--border);height:var(--task-header-height);min-height:var(--task-header-height);}
    .task-list-header span{display:flex;align-items:center;justify-content:flex-end;padding:0 .35rem;}
    .task-header-identifier{justify-content:center;}
    .task-header-name{justify-content:flex-start;}
    .task-list-scroll{display:flex;flex-direction:column;padding-bottom: 17px;justify-content:flex-start;flex:1;overflow-y:auto;overflow-x:visible;max-height:var(--task-scroll-height);scrollbar-gutter:stable;background:var(--surface);min-height:0;direction:rtl;scroll-padding-top:var(--task-header-height);}
    .task-list-scroll > *{direction:ltr;}
    .task-list{flex:0;overflow:visible;padding:0;min-height:0;margin-top:0;transform:none;}
    .task-row{align-items:center;padding:0 1.5rem;height:var(--row-height);border-bottom:1px solid rgba(15,23,42,.06);cursor:pointer;transition:background .15s ease,box-shadow .15s ease;font-size:.7rem;}
    .task-row > *{width:100%;box-sizing:border-box;height:100%;display:flex;align-items:center;padding:0 .35rem;}
    .task-row .task-identifier{justify-content:center;font-weight:700;font-size:.595rem;text-transform:uppercase;font-variant-numeric:tabular-nums;color:var(--text);}
    .task-row.stage-row .task-identifier{color:#7c6c1f;}
    .task-row .task-identifier.identifier-placeholder{color:var(--text-muted);font-weight:600;}
    .task-row .task-name{justify-content:flex-start;}
    .task-row .task-start,
    .task-row .task-end,
    .task-row .task-duration-cell,
    .task-row .task-progress{justify-content:flex-end;}
    .task-row:hover{background:rgba(48,86,211,.08);}
    .task-row.selected{background:rgba(48,86,211,.14);box-shadow:inset 4px 0 0 var(--primary);}
    .task-row.dragging{opacity:.55;}
    .task-row.drag-over{background:rgba(48,86,211,.18);box-shadow:inset 0 0 0 2px rgba(48,86,211,.35);}
    .task-row.stage-row{background:rgb(250,250,210);}
    .task-row.stage-row.selected{box-shadow:inset 4px 0 0 rgba(212,163,18,.85);}
    .task-row.stage-child .task-name{padding-left:1.25rem;}
    .task-row.stage-row .stage-meta-hidden{visibility:hidden;pointer-events:none;}
    .task-name{display:flex;align-items:center;font-size:inherit;font-weight:600;color:var(--text);}
    .task-duration{font-size:.7rem;font-weight:600;text-align:center;padding:.3rem .5rem;border-radius:999px;background:rgba(48,86,211,.12);color:var(--primary);height:30px;display:inline-flex;align-items:center;justify-content:center;line-height:1;}
    .task-progress{position:relative;display:flex;align-items:center;justify-content:flex-end;gap:.2rem;height:100%;}
    .task-row input[type="date"],.task-row input[type="number"]{font-size:.7rem;padding:.25rem .4rem;height:30px;line-height:30px;}
    .task-row input[type="date"]{width:100%;}
    .task-progress input{text-align:right;width:68px;min-width:unset;padding-right:1.3rem;}
    .task-progress span{position:relative;right:.35rem;transform:none;font-size:.65rem;color:var(--text-muted);}
    .gantt-wrapper{flex:1;display:flex;flex-direction:column;min-width:0;}
    .gantt-header{padding:0rem 1.75rem 1rem;display:flex;justify-content:space-between;align-items:center;gap:1rem;flex-wrap:wrap;position:sticky;top:var(--top-offset);z-index:5;background:#fff;}
    .gantt-header h2{font-size:1.2rem;font-weight:600;}
    .gantt-header-left{display:inline-flex;align-items:center;gap:.75rem;flex-wrap:wrap;}
    .timeline-controls{display:flex;align-items:center;gap:.6rem;flex-wrap:wrap;}
    .view-mode-toggle{display:inline-flex;align-items:center;background:var(--surface-alt);border:1px solid var(--border);border-radius:999px;padding:2px;}
    .view-mode-toggle button{border:0;background:transparent;color:var(--text-muted);font-size:.75rem;font-weight:600;padding:.3rem .75rem;border-radius:999px;cursor:pointer;transition:background .15s ease,color .15s ease,box-shadow .15s ease;}
    .view-mode-toggle button.active{background:var(--primary);color:#fff;box-shadow:0 6px 14px rgba(48,86,211,.2);}
    .view-mode-toggle button:focus-visible{outline:2px solid rgba(48,86,211,.35);outline-offset:2px;}
    .zoom-controls{display:inline-flex;align-items:center;background:var(--surface-alt);border:1px solid var(--border);border-radius:999px;padding:2px;}
    .zoom-controls button{border:0;background:transparent;color:var(--text-muted);font-size:.85rem;font-weight:700;padding:.28rem .6rem;border-radius:999px;cursor:pointer;transition:background .15s ease,color .15s ease,box-shadow .15s ease;}
    .zoom-controls button:hover:not(:disabled){color:var(--primary);background:rgba(48,86,211,.12);}
    .zoom-controls button:disabled{cursor:not-allowed;opacity:.45;}
    .zoom-controls button:focus-visible{outline:2px solid rgba(48,86,211,.35);outline-offset:2px;}
    .planner-viewport{flex:1;display:flex;overflow-x:auto;overflow-y:hidden;position:relative;min-height:0;min-width:0;scrollbar-gutter:stable both-edges;align-items:flex-start;scroll-padding-top:var(--content-offset);padding-top:var(--content-offset);box-sizing:border-box;}
    .gantt-calendar{flex:1;background:var(--surface);border-top:1px solid var(--border);position:relative;display:flex;flex-direction:column;min-width:0;}
    .timeline-header{position:sticky;top:var(--timeline-header-top, calc(var(--top-offset) + var(--content-offset)));z-index:5;display:grid;background:#fff;border-bottom:1px solid var(--border);box-shadow:0 4px 12px rgba(15,23,42,.08);grid-auto-flow:column;height:var(--timeline-header-height);min-height:var(--timeline-header-height);align-content:stretch;}
    .timeline-header .timeline-year,
    .timeline-header .timeline-month,
    .timeline-header .timeline-week{display:flex;align-items:center;justify-content:center;padding:.4rem .6rem;font-weight:700;font-size:.78rem;color:var(--text);border-left:1px solid rgba(15,23,42,.08);background:rgba(48,86,211,.06);}
    .timeline-header .timeline-month{font-weight:600;font-size:.75rem;color:var(--text-muted);background:rgba(48,86,211,.02);}
    .timeline-header .timeline-week{background:rgba(48,86,211,.08);color:var(--text);}
    .timeline-header .timeline-day-name,
    .timeline-header .timeline-day-number{display:flex;align-items:center;justify-content:center;padding:.35rem .25rem;border-left:1px solid rgba(15,23,42,.06);}
    .timeline-header > *{position:relative;z-index:2;}
    .timeline-highlight{background:rgba(220,38,38,.12);border-left:2px solid transparent;border-right:2px solid transparent;border-radius:6px;pointer-events:none;z-index:1;}
    .timeline-highlight--today{background:rgba(220,38,38,.12);border-color:#dc2626;}
    .timeline-highlight--deadline{background:rgba(253,224,140,.28);border-color:#d97706;}
    .timeline-highlight--standdown{background:rgba(148,163,184,.28);border-color:#475569;}
    .timeline-header.week-view .timeline-highlight{border-radius:4px;}
    .timeline-header .timeline-day-name.today,
    .timeline-header .timeline-day-number.today,
    .timeline-header .timeline-week.today{color:#dc2626;font-weight:700;}
    .timeline-header .timeline-day-name.milestone-deadline,
    .timeline-header .timeline-day-number.milestone-deadline,
    .timeline-header .timeline-week.milestone-deadline{color:#b45309;font-weight:700;}
    .timeline-header .timeline-day-name.milestone-standdown,
    .timeline-header .timeline-day-number.milestone-standdown,
    .timeline-header .timeline-week.milestone-standdown{color:#334155;font-weight:700;}
    .timeline-header .timeline-day-name{font-size:.72rem;font-weight:600;color:var(--text-muted);letter-spacing:.03em;text-transform:uppercase;}
    .timeline-header .timeline-day-number{font-size:.76rem;font-weight:700;color:var(--text);}
    .timeline-header .timeline-year:first-child,
    .timeline-header .timeline-month:first-child,
    .timeline-header .timeline-week:first-child,
    .timeline-header .timeline-day-name:first-child,
    .timeline-header .timeline-day-number:first-child{border-left:none;}
    .timeline-header.week-view .timeline-year,
    .timeline-header.week-view .timeline-month{background:rgba(48,86,211,.04);}
    .gantt-body-scroll{flex:0;overflow-y:auto;overflow-x:visible;max-height:var(--gantt-scroll-height);scrollbar-gutter:stable;background:var(--surface);min-height:0;scroll-padding-top:var(--timeline-header-height);margin-top: -2px;}
    .gantt-body{margin-top:0;display:flex;flex-direction:column;gap:0;transition:margin-top .2s ease;min-width:100%;}
    .gantt-row{position:relative;height:var(--row-height);min-width:100%;overflow:visible;border-bottom: 1px solid rgba(15,23,42,.06);}
    .gantt-row.stage-row{background:transparent;}
    .gantt-row.stage-child .task-label{padding-left:1rem;}
    .gantt-grid{position:absolute;inset:0;display:grid;pointer-events:none;z-index:0;}
    .gantt-grid .day-cell{position:relative;border-left:1px solid rgba(15,23,42,.05);background:rgba(240,243,248,.9);}
    .gantt-grid .day-cell:nth-child(5n+1){background:rgba(48,86,211,.08);}
    .gantt-grid .day-cell::before,
    .gantt-grid .day-cell::after{content:"";position:absolute;top:0;bottom:0;left:0;right:0;border-radius:6px;pointer-events:none;}
    .gantt-grid .day-cell::before{background:transparent;opacity:0;}
    .gantt-grid .day-cell.milestone-deadline::before{background:rgba(253,224,140,.28);border-left:2px solid #d97706;border-right:2px solid #d97706;opacity:1;}
    .gantt-grid .day-cell.milestone-standdown::before{background:rgba(148,163,184,.32);border-left:2px solid #475569;border-right:2px solid #475569;opacity:1;}
    .gantt-grid .day-cell.today::after{background:rgba(220,38,38,.12);border-left:2px solid #dc2626;border-right:2px solid #dc2626;}
    .stage-empty-label{position:absolute;left:12px;top:50%;transform:translateY(-50%);font-weight:600;color:#7c6c1f;pointer-events:none;}
    .task-bar{position:absolute;top:50%;transform:translateY(-50%);height:35px;min-height:35px;border-radius:8px;background:rgba(48,86,211,.22);border:1px solid rgba(48,86,211,.32);display:flex;flex-direction:column;align-items:flex-start;justify-content:center;gap:.12rem;padding:.25rem .7rem;cursor:pointer;transition:box-shadow .2s ease,transform .2s ease;overflow:visible;}
    .task-bar:hover{transform:translateY(calc(-50% - 0.5px));box-shadow:0 12px 22px rgba(48,86,211,.2);}
    .task-bar.selected{background:rgba(48,86,211,.32);border-color:rgba(48,86,211,.55);box-shadow:0 12px 26px rgba(48,86,211,.26);}
    .task-bar.stage-bar{background:rgb(250,250,210)!important;border-color:rgba(212,163,18,.85)!important;box-shadow:0 2px 6px rgba(212,163,18,.25);}
    .task-bar.stage-bar:hover,
    .task-bar.stage-bar.selected{background:rgb(255,247,190)!important;border-color:rgba(180,140,0,.9)!important;}
    .task-bar.stage-bar .progress{background:rgba(255,255,255,.35);}
    .task-label{font-size:.85rem;font-weight:600;line-height:1.05;white-space:nowrap;pointer-events:none;color:#000;position:relative;z-index:5;text-shadow:0 1px 2px rgba(255,255,255,.25);max-width:100%;overflow:hidden;text-overflow:ellipsis;}
    .task-dates{font-size:.74rem;line-height:1.05;color:rgba(0,0,0,.72);pointer-events:none;position:relative;z-index:5;max-width:100%;overflow:hidden;text-overflow:ellipsis;}
    .task-bar .progress{position:absolute;top:0;bottom:0;left:0;width:0;background:repeating-linear-gradient(135deg,rgba(255,255,255,.9)0,rgba(255,255,255,.9)6px,rgba(255,255,255,.25)6px,rgba(255,255,255,.25)12px);background-color:rgba(255,255,255,.25);border-radius:8px 0 0 8px;pointer-events:none;transition:width .2s ease;z-index:5;box-shadow:inset -1px 0 0 rgba(0,0,0,.08);overflow:hidden;}
    .task-bar .progress.is-full{border-radius:8px;}
    .mini-layer{position:absolute;inset:0;pointer-events:auto;border-radius:8px;overflow:visible;z-index:4;}
    .single-event-marker{position:absolute;top:50%;transform:translate(-50%,-50%);width:0;height:0;border-left:10px solid transparent;border-right:10px solid transparent;border-bottom:16px solid #2fb879;cursor:pointer;pointer-events:auto;z-index:6;}
    .single-event-marker:hover{filter:brightness(1.05);}
    .single-event-marker.selected{border-bottom-color:#228a5f;}
    .mini-segment{position:absolute;top:0;bottom:0;opacity:.92;pointer-events:auto;border-radius:10px;box-shadow:inset 0 0 0 1px rgba(15,23,42,.12);cursor:pointer;transition:box-shadow .15s ease;}
    .mini-segment.locked{box-shadow:inset 0 0 0 3px rgba(17,24,39,.65);}
    .mini-segment.undefined{background:rgb(245,245,245);box-shadow:inset 0 0 0 1px rgba(107,114,128,.35);}
    .mini-segment .mini-handle{position:absolute;top:50%;transform:translateY(-50%);width:16px;height:70%;border-radius:10px;cursor:col-resize;background:transparent;border:1px solid transparent;box-shadow:none;display:flex;align-items:center;justify-content:center;z-index:5;transition:transform .15s ease;}
    .mini-segment .mini-handle::before{display:none;}
    .mini-segment .mini-handle:hover{transform:translateY(-50%) scale(1.05);}
    .mini-segment .mini-handle-left{left:-7px;}
    .mini-segment .mini-handle-right{right:-7px;}
    .mini-segment .mini-handle.disabled{cursor:not-allowed;opacity:.2;background:transparent;box-shadow:none;}
    .mini-segment.locked .mini-handle{cursor:not-allowed;background:transparent;opacity:.2;}
    .mini-segment.locked .mini-handle:hover{background:transparent;}
    .standdown-layer{position:absolute;inset:0;pointer-events:none;z-index:3;}
    .standdown-gap{position:absolute;top:-1px;bottom:-1px;background:rgba(55,65,81,.7);border-left:1px dashed rgba(31,41,55,.8);border-right:1px dashed rgba(31,41,55,.8);box-shadow:inset 0 0 0 1px rgba(17,24,39,.36);}
    .mini-0{background:rgba(48,86,211,.88);} .mini-1{background:rgba(46,160,67,.85);} .mini-2{background:rgba(191,135,0,.85);} .mini-3{background:rgba(219,97,162,.85);} .mini-4{background:rgba(137,87,229,.85);} .mini-5{background:rgba(64,193,213,.85);} .mini-6{background:rgba(231,120,67,.85);}
    .handle{position:absolute;top:0;bottom:0;width:10px;background:rgba(15,23,42,.18);border-radius:4px;cursor:ew-resize;opacity:0;transition:opacity .15s ease;z-index:6;}
    .task-bar:hover .handle,.task-bar.selected .handle{opacity:1;}
    .handle-start{left:-4px;}
    .handle-end{right:-4px;}
    .empty-state{padding:2rem 1.5rem;color:var(--text-muted);font-size:.95rem;text-align:center;}
    .modal-backdrop{position:fixed;inset:0;background:rgba(15,23,42,.45);backdrop-filter:blur(2px);z-index:10;}
    .modal{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:11;padding:2rem;}
    .modal.hidden,.modal-backdrop.hidden{display:none;}
    .modal-content{background:#fff;border-radius:14px;width:min(720px,96vw);max-height:92vh;display:flex;flex-direction:column;box-shadow:0 28px 64px rgba(15,23,42,.3);overflow:auto;}
    .modal-header{padding:1.3rem 1.75rem 1rem;border-bottom:1px solid rgba(15,23,42,.08);display:flex;align-items:center;justify-content:space-between;}
    .modal-body{padding:1.4rem 1.75rem;display:flex;flex-direction:column;gap:1.4rem;}
    .form-grid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:1rem 1.4rem;}
    .form-group{display:flex;flex-direction:column;gap:.4rem;font-size:.88rem;}
    .form-group label{font-weight:600;color:var(--text-muted);}
    .duration-indicator{display:inline-flex;align-items:center;gap:.4rem;padding:.35rem .6rem;border-radius:999px;background:rgba(48,86,211,.12);color:var(--primary);font-size:.8rem;font-weight:600;}
    .mini-task-section{border:1px solid rgba(15,23,42,.08);border-radius:12px;background:rgba(48,86,211,.05);padding:1.1rem 1.4rem;display:flex;flex-direction:column;gap:1rem;}
    .mini-task-section h3{font-size:1rem;font-weight:700;}
    .mini-task-section p{margin:0;font-size:.85rem;color:var(--text-muted);}
    .mini-task-header{display:flex;justify-content:space-between;align-items:flex-start;gap:.8rem;flex-wrap:wrap;}
    .mini-task-heading{flex:1 1 auto;min-width:220px;}
    .mini-task-toolbar{display:inline-flex;align-items:center;gap:.4rem;}
    .mini-task-toolbar button{border:1px solid var(--border);background:#fff;color:var(--text);border-radius:8px;padding:.32rem .65rem;font-size:.82rem;font-weight:600;cursor:pointer;transition:color .15s ease,border-color .15s ease,transform .15s ease;}
    .mini-task-toolbar button:hover:not(:disabled){color:var(--primary);border-color:var(--primary);transform:translateY(-1px);}
    .mini-task-toolbar button:disabled{cursor:not-allowed;opacity:.45;transform:none;}
    .mini-task-controls-row{display:flex;justify-content:flex-end;align-items:center;gap:.6rem;flex-wrap:wrap;margin-top:-.3rem;}
    .mini-unit-toggle{display:inline-flex;align-items:center;background:#fff;border:1px solid var(--border);border-radius:999px;padding:2px;}
    .mini-unit-toggle .mini-unit-btn{border:0;background:transparent;color:var(--text-muted);font-size:.74rem;font-weight:600;padding:.28rem .6rem;border-radius:999px;cursor:pointer;transition:background .15s ease,color .15s ease;}
    .mini-unit-toggle .mini-unit-btn.active{background:var(--primary);color:#fff;}
    .mini-unit-toggle .mini-unit-btn:focus-visible{outline:2px solid rgba(48,86,211,.35);outline-offset:2px;}
    .mini-task-list{display:flex;flex-direction:column;gap:.8rem;}
    .mini-task-item{display:grid;grid-template-columns:auto 300px 110px auto;gap:.55rem;align-items:center;padding:.45rem .65rem;border-radius:10px;background:rgba(255,255,255,.9);border:1px solid rgba(15,23,42,.05);transition:box-shadow .15s ease, border-color .15s ease;}
    .mini-task-item.duration-focused{box-shadow:0 0 0 2px rgba(48,86,211,.35);border-color:rgba(48,86,211,.55);}
    .mini-task-item.locked{border-color:rgba(48,86,211,.6);box-shadow:0 0 0 2px rgba(48,86,211,.45) inset;}
    .mini-task-item.disabled{opacity:.4;}
    .mini-task-item label{display:flex;align-items:center;gap:.4rem;font-weight:600;font-size:.82rem;}
    .mini-task-item input[type="checkbox"]{width:18px;height:18px;accent-color:var(--primary);}
    .mini-task-item select{font:inherit;border-radius:6px;border:1px solid var(--border);padding:.4rem .5rem;background:#fff;color:inherit;}
    .mini-task-item select:disabled{background:#fff;}
    .mini-task-duration{display:flex;align-items:center;gap:.3rem;font-size:.75rem;color:var(--text-muted);}
    .mini-task-duration input{width:58px;text-align:right;padding-right:.3rem;font-size:.75rem;height:28px;}
    .mini-task-controls{display:flex;flex-direction:column;gap:.35rem;align-items:center;align-self:flex-start;}
    .mini-task-controls button{width:28px;height:28px;border:1px solid var(--border);border-radius:6px;background:#fff;color:var(--text);font-size:.8rem;font-weight:600;display:flex;align-items:center;justify-content:center;padding:0;cursor:pointer;transition:color .15s ease,border-color .15s ease,transform .15s ease;}
    .mini-task-controls button:hover:not(:disabled){color:var(--primary);border-color:var(--primary);transform:translateY(-1px);}
    .mini-task-controls button:disabled{opacity:.35;cursor:not-allowed;transform:none;}
    .single-event-toggle{display:inline-flex;align-items:center;gap:.5rem;font-weight:600;color:var(--text);}
    .single-event-toggle input{width:18px;height:18px;accent-color:var(--primary);}
    .mini-delay-extras{display:none;grid-column:1 / -1;width:100%;flex-direction:column;align-items:flex-start;gap:.5rem;margin-top:.4rem;}
    .mini-task-item.delay-active .mini-delay-extras{display:flex;}
    .mini-task-item.delay-active .mini-task-duration{margin-bottom:.2rem;}
    .mini-delay-extras textarea{font-size:.8rem;padding:.35rem .5rem;border:1px solid var(--border);border-radius:6px;width:300px;min-height:96px;resize:vertical;}
    .mini-delay-extras textarea:disabled{background:#f9fafb;color:var(--text-muted);cursor:not-allowed;}
    .mini-delay-extras .mini-delay-charge{display:flex;align-items:center;gap:.4rem;font-size:.76rem;color:var(--text-muted);}
    .delay-modal-backdrop{position:fixed;inset:0;background:rgba(15,23,42,.45);backdrop-filter:blur(2px);z-index:14;}
    .delay-modal{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:15;padding:2rem;}
    .delay-modal.hidden,.delay-modal-backdrop.hidden{display:none;}
    .delay-modal-content{background:#fff;border-radius:14px;width:min(720px,95vw);max-height:92vh;display:flex;flex-direction:column;box-shadow:0 28px 64px rgba(15,23,42,.3);overflow:hidden;}
    .delay-modal-header{display:flex;align-items:center;justify-content:space-between;padding:1.2rem 1.5rem;border-bottom:1px solid rgba(15,23,42,.08);}
    .delay-modal-header h2{margin:0;font-size:1.2rem;font-weight:700;}
    .delay-close-btn{border:none;background:transparent;font-size:1.4rem;line-height:1;cursor:pointer;color:var(--text-muted);padding:.2rem .4rem;border-radius:6px;}
    .delay-close-btn:hover{color:var(--primary);}
    .delay-modal-body{padding:1.2rem 1.5rem;overflow:auto;}
    .delay-table{width:100%;border-collapse:collapse;font-size:.85rem;}
    .delay-table th,.delay-table td{border:1px solid rgba(15,23,42,.12);padding:.55rem .6rem;text-align:left;vertical-align:middle;white-space:normal;word-break:break-word;}
    .delay-table thead{background:rgba(48,86,211,.08);font-weight:700;}
    .delay-table tbody tr:nth-child(even){background:rgba(248,250,255,.7);}
    .delay-table tbody tr:hover{background:rgba(48,86,211,.1);}
    .delay-table tbody textarea{width:300px;max-width:100%;box-sizing:border-box;font-size:.82rem;padding:.3rem .45rem;border:1px solid rgba(15,23,42,.2);border-radius:6px;min-height:96px;resize:vertical;}
    .delay-charge-cell{padding:0;text-align:center;vertical-align:middle;}
    .delay-charge-cell .delay-charge-wrapper{display:flex;justify-content:center;align-items:center;height:100%;padding:.55rem 0;}
    .delay-table-empty{text-align:center;color:var(--text-muted);font-style:italic;}
    .modal-footer{padding:1rem 1.75rem 1.35rem;border-top:1px solid rgba(15,23,42,.08);display:flex;justify-content:flex-end;gap:.75rem;}
    .modal-footer .secondary{background:#fff;color:var(--text);border:1px solid var(--border);}
    .modal-footer .secondary:hover{color:var(--primary);border-color:var(--primary);transform:none;}
    .app-branding{position:fixed;bottom:1.5rem;left:1.5rem;display:flex;align-items:center;gap:.75rem;z-index:4;}
    .app-branding img{width:80px;height:80px;object-fit:contain;}
    .app-branding-text{font-size:.9rem;color:var(--text-muted);font-weight:600;}
    .schedule-modal-backdrop{position:fixed;inset:0;background:rgba(15,23,42,.45);backdrop-filter:blur(2px);z-index:12;}
    .schedule-modal{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:13;padding:2rem;}
    .schedule-modal.hidden,.schedule-modal-backdrop.hidden{display:none;}
    .schedule-modal-content{background:#fff;border-radius:14px;width:min(660px,95vw);max-height:92vh;display:flex;flex-direction:column;box-shadow:0 28px 64px rgba(15,23,42,.3);}
    .schedule-modal-header{padding:1.4rem 1.75rem 1rem;border-bottom:1px solid rgba(15,23,42,.08);display:flex;flex-direction:column;gap:.45rem;}
    .schedule-modal-header h2{margin:0;font-size:1.25rem;font-weight:700;}
    .schedule-modal-header p{margin:0;font-size:.88rem;color:var(--text-muted);}
    .schedule-modal-body{padding:1.4rem 1.75rem;display:flex;flex-direction:column;gap:1rem;overflow:auto;}
    .milestone-toolbar{display:flex;gap:.6rem;flex-wrap:wrap;}
    .milestone-toolbar button{background:var(--primary);color:#fff;border:none;border-radius:8px;padding:.45rem 1rem;font-size:.85rem;font-weight:600;cursor:pointer;transition:transform .15s ease,box-shadow .15s ease;}
    .milestone-toolbar button:hover{transform:translateY(-1px);box-shadow:0 8px 16px rgba(48,86,211,.18);}
    .milestone-toolbar button:disabled{opacity:.4;cursor:not-allowed;transform:none;box-shadow:none;}
    .milestone-toolbar .neutral{background:#fff;color:var(--text);border:1px solid var(--border);box-shadow:none;}
    .milestone-toolbar .neutral:hover{transform:none;color:var(--primary);border-color:var(--primary);}
    .milestone-list{list-style:none;margin:0;padding:0;display:flex;flex-direction:column;gap:.75rem;}
    .milestone-item{display:grid;grid-template-columns:minmax(0,1fr) 140px repeat(2,minmax(130px,1fr));gap:.75rem;align-items:center;padding:.8rem 1rem;border:1px solid rgba(15,23,42,.08);border-radius:10px;background:rgba(248,250,255,.9);position:relative;cursor:pointer;transition:border-color .15s ease,box-shadow .15s ease,background .15s ease;}
    .milestone-item:hover{border-color:rgba(48,86,211,.35);box-shadow:0 12px 28px rgba(15,23,42,.16);}
    .milestone-item.selected{border-color:var(--primary);box-shadow:0 14px 34px rgba(48,86,211,.24);background:#fff;}
    .milestone-item .field{display:flex;flex-direction:column;gap:.3rem;}
    .milestone-item .field label{font-size:.72rem;font-weight:600;color:var(--text-muted);}
    .milestone-item input[type="text"]{border:1px solid var(--border);border-radius:8px;padding:.4rem .6rem;font-size:.85rem;}
    .milestone-item select,
    .milestone-item input[type="date"]{border:1px solid var(--border);border-radius:8px;padding:.35rem .5rem;font-size:.8rem;}
    .milestone-item .placeholder{display:flex;align-items:center;justify-content:center;font-size:.78rem;color:var(--text-muted);background:rgba(15,23,42,.04);border:1px dashed rgba(15,23,42,.16);border-radius:8px;padding:.45rem;}
    .empty-milestones{padding:1.2rem;border:1px dashed rgba(15,23,42,.2);border-radius:12px;text-align:center;color:var(--text-muted);font-size:.9rem;}
    .schedule-modal-footer{padding:1rem 1.75rem 1.35rem;border-top:1px solid rgba(15,23,42,.08);display:flex;justify-content:flex-end;gap:.75rem;background:#fff;border-radius:0 0 14px 14px;}
    .schedule-modal-footer .secondary{background:#fff;color:var(--text);border:1px solid var(--border);padding:.55rem 1.15rem;font-size:.9rem;border-radius:8px;}
    .schedule-modal-footer .secondary:hover{color:var(--primary);border-color:var(--primary);transform:none;}
    .schedule-modal-footer button:not(.secondary){background:var(--primary);color:#fff;border:none;padding:.55rem 1.25rem;font-size:.95rem;font-weight:600;border-radius:8px;cursor:pointer;transition:transform .15s ease,box-shadow .15s ease;}
    .schedule-modal-footer button:not(.secondary):hover{transform:translateY(-1px);box-shadow:0 10px 20px rgba(48,86,211,.18);}
    .generate-modal-backdrop{position:fixed;inset:0;background:rgba(15,23,42,.45);backdrop-filter:blur(2px);z-index:12;}
    .generate-modal{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:13;padding:2rem;}
    .generate-modal.hidden,.generate-modal-backdrop.hidden{display:none;}
    .generate-modal-content{background:#fff;border-radius:14px;width:min(520px,92vw);max-height:90vh;display:flex;flex-direction:column;box-shadow:0 28px 64px rgba(15,23,42,.3);}
    .generate-modal-header{padding:1.4rem 1.75rem 1rem;border-bottom:1px solid rgba(15,23,42,.08);display:flex;flex-direction:column;gap:.4rem;}
    .generate-modal-header h2{margin:0;font-size:1.2rem;font-weight:700;}
    .generate-modal-header p{margin:0;font-size:.9rem;color:var(--text-muted);}
    .generate-modal-body{padding:1.4rem 1.75rem;overflow:auto;}
    .generate-modal-footer{padding:1rem 1.75rem 1.3rem;border-top:1px solid rgba(15,23,42,.08);display:flex;justify-content:flex-end;gap:.75rem;background:#fff;border-radius:0 0 14px 14px;}
    .generate-modal-footer .secondary{background:#fff;color:var(--text);border:1px solid var(--border);border-radius:8px;padding:.55rem 1.1rem;font-size:.9rem;}
    .generate-modal-footer .secondary:hover{color:var(--primary);border-color:var(--primary);}
    .generate-modal-footer button:not(.secondary){background:var(--primary);color:#fff;border:none;padding:.55rem 1.25rem;font-size:.95rem;font-weight:600;border-radius:8px;cursor:pointer;transition:transform .15s ease,box-shadow .15s ease;}
    .generate-modal-footer button:not(.secondary):hover{transform:translateY(-1px);box-shadow:0 10px 20px rgba(48,86,211,.18);}
    @media(max-width:1200px){:root{--sidebar-width:320px;--day-width:28px;}}
    @media(max-width:960px){:root{--sidebar-width:100%;}.app{flex-direction:column;}.sidebar{width:100%;flex:auto;max-height:55vh;border-right:none;border-bottom:1px solid var(--border);position:relative;left:auto;z-index:auto;}.task-list-header,.task-row{grid-template-columns:64px minmax(0,1.2fr) 92px 92px 92px 76px;}.task-duration{display:none;}}
  </style>
</head>
<body>
  <header class="top-bar">
    <div class="top-bar-row heading-row">
      <div class="project-heading">
        <h1>Project 14.0</h1>
      </div>
    </div>
    <div class="top-bar-row primary-actions-row">
      <div class="button-row">
        <button type="button" id="generateScheduleBtn">Generate Schedule</button>
        <button type="button" id="scheduleSettingsBtn" class="secondary">Schedule Settings</button>
        <button type="button" id="delayScheduleBtn" class="secondary">Delays Schedule</button>
        <button type="button" id="graphAuthBtn" class="secondary">Sign in to OneDrive</button>
        <button type="button" id="saveProgrammeBtn" class="secondary">Save Programme</button>
        <button type="button" id="loadProgrammeBtn" class="secondary">Load Programme</button>
        <button type="button" id="savePdfBtn">Save PDF</button>
      </div>
    </div>
    <div class="top-bar-row legend-row">
      <div class="legend" id="taskLegend"></div>
    </div>
    <div class="top-bar-row secondary-actions-row">
      <div class="sidebar-actions top-bar-sidebar-actions">
        <button id="addTaskBtn" type="button">＋ New</button>
        <button id="removeTaskBtn" class="secondary" type="button" disabled>- Remove</button>
        <button id="editTaskBtn" class="secondary" type="button" disabled>Edit</button>
        <button id="moveUpBtn" class="secondary icon-btn" type="button" disabled title="Move task up" aria-label="Move task up">↑</button>
        <button id="moveDownBtn" class="secondary icon-btn" type="button" disabled title="Move task down" aria-label="Move task down">↓</button>
      </div>
      <div class="timeline-controls">
        <div class="view-mode-toggle" role="group" aria-label="Timeline view mode">
          <button type="button" class="view-mode-btn active" data-view-mode="days" aria-pressed="true">Days</button>
          <button type="button" class="view-mode-btn" data-view-mode="weeks" aria-pressed="false">Weeks</button>
        </div>
        <div class="zoom-controls" role="group" aria-label="Timeline zoom">
          <button type="button" id="zoomOutBtn" aria-label="Zoom out">-</button>
          <button type="button" id="zoomInBtn" aria-label="Zoom in">+</button>
        </div>
      </div>
    </div>
  </header>
  <div class="app">
    <div class="planner-viewport" id="plannerViewport">
      <aside class="sidebar">
        <div class="task-list-header">
          <span class="task-header-identifier">ID</span>
          <span class="task-header-name">Task</span>
          <span class="task-header-start">Start</span>
          <span class="task-header-end">End</span>
          <span class="task-header-duration">Duration</span>
          <span class="task-header-progress">Progress</span>
        </div>
        <div class="task-list-scroll">
          <div class="task-list" id="taskList"></div>
        </div>
      </aside>
      <main class="gantt-wrapper">
        <div class="gantt-calendar">
          <div class="timeline-header" id="timelineHeader"></div>
          <div class="gantt-body-scroll">
            <div class="gantt-body" id="ganttBody"></div>
          </div>
        </div>
      </main>
    </div>
  </div>

  <div class="app-branding">
    <img src="assets/bb-logo.png" alt="BB Programme logo">
    <span class="app-branding-text">Programme Tool : Version 14.2</span>
  </div>

  <div class="modal-backdrop hidden" id="modalBackdrop"></div>
  <div class="modal hidden" id="taskModal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
    <div class="modal-content">
      <form id="taskForm">
        <div class="modal-header">
          <h2 id="modalTitle">New</h2>
          <span class="duration-indicator" id="durationPreview">0 working days</span>
        </div>
        <div class="modal-body">
          <div class="form-grid">
            <div class="form-group" style="grid-column:span 2;">
              <label for="modalEntryType">Create</label>
              <select id="modalEntryType" name="entryType">
                <option value="task">Task</option>
                <option value="single">Single Event</option>
                <option value="stage">Stage</option>
              </select>
            </div>
            <div class="form-group" id="progressGroup">
              <label for="modalTaskProgress">Progress (%)</label>
              <input id="modalTaskProgress" name="taskProgress" type="number" min="0" max="100" value="0">
            </div>
            <div class="form-group" id="nameGroup">
              <label id="modalNameLabel" for="modalTaskName">Task name</label>
              <input id="modalTaskName" name="taskName" type="text" placeholder="e.g. Design Development">
            </div>
            <div class="form-group" id="stagePresetGroup">
              <label for="modalStagePreset">Stage name</label>
              <select id="modalStagePreset" name="stagePreset"></select>
            </div>
            <div class="form-group" id="stageCustomNameGroup">
              <label for="modalStageCustomName">Description</label>
              <input id="modalStageCustomName" name="stageCustomName" type="text" placeholder="Enter stage name">
            </div>
            <div class="form-group" id="descriptionGroup" style="grid-column:span 2;">
              <label for="modalTaskDescription">Description</label>
              <textarea id="modalTaskDescription" name="taskDescription" placeholder="Task goals, deliverables, or notes"></textarea>
            </div>
            <div class="form-group" id="startDateGroup">
              <label id="modalStartDateLabel" for="modalStartDate">Start date</label>
              <input id="modalStartDate" name="taskStart" type="date">
            </div>
            <div class="form-group" id="endDateGroup">
              <label for="modalEndDate">End date</label>
              <input id="modalEndDate" name="taskEnd" type="date">
            </div>
          </div>

          <div class="mini-task-section" id="miniTaskSection">
            <div class="mini-task-header">
              <div class="mini-task-heading">
                <h3>Sequenced steps</h3>
                <p>Use ＋/− to add or remove steps. Durations always add up to the main task and display on the Gantt bar.</p>
              </div>
              <div class="mini-task-toolbar" role="group" aria-label="Mini-task controls">
                <button type="button" id="addMiniTaskBtn" aria-label="Add mini-task">＋</button>
                <button type="button" id="removeMiniTaskBtn" aria-label="Remove mini-task">−</button>
              </div>
            </div>
            <div class="mini-task-controls-row">
              <div class="mini-unit-toggle" role="group" aria-label="Mini-task duration unit">
                <button type="button" class="mini-unit-btn active" data-unit="days" aria-pressed="true">Days</button>
                <button type="button" class="mini-unit-btn" data-unit="weeks" aria-pressed="false">Weeks</button>
              </div>
            </div>
            <div class="mini-task-list" id="miniTaskList"></div>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="secondary" id="cancelModalBtn">Cancel</button>
          <button type="submit" id="saveTaskBtn">Save Task</button>
        </div>
      </form>
    </div>
  </div>

  <div class="schedule-modal-backdrop hidden" id="scheduleModalBackdrop"></div>
  <div class="schedule-modal hidden" id="scheduleModal" role="dialog" aria-modal="true" aria-labelledby="scheduleModalTitle">
    <div class="schedule-modal-content">
      <div class="schedule-modal-header">
        <h2 id="scheduleModalTitle">Schedule Settings</h2>
        <p>Configure milestones to highlight on the programme timeline.</p>
      </div>
      <div class="schedule-modal-body">
        <div class="milestone-toolbar">
          <button type="button" id="addMilestoneBtn">＋ Add Milestone</button>
          <button type="button" id="removeMilestoneBtn" class="neutral" disabled>− Remove Selected</button>
        </div>
        <ul class="milestone-list" id="milestoneList"></ul>
      </div>
      <div class="schedule-modal-footer">
        <button type="button" class="secondary" id="cancelScheduleBtn">Cancel</button>
        <button type="button" id="saveScheduleBtn">Save</button>
      </div>
    </div>
  </div>

  <div class="generate-modal-backdrop hidden" id="generateModalBackdrop"></div>
  <div class="generate-modal hidden" id="generateModal" role="dialog" aria-modal="true" aria-labelledby="generateModalTitle">
    <div class="generate-modal-content">
      <div class="generate-modal-header">
        <h2 id="generateModalTitle">Generate Schedule</h2>
        <p>Set the project parameters and create a suggested programme.</p>
      </div>
      <form id="generateForm">
        <div class="generate-modal-body">
          <div class="form-grid">
            <div class="form-group">
              <label for="buildingTypeSelect">Building Type</label>
              <select id="buildingTypeSelect" required></select>
            </div>
            <div class="form-group">
              <label for="projectDifficultyInput">Project Difficulty</label>
              <input id="projectDifficultyInput" type="number" min="1" max="10" value="1" required>
            </div>
            <div class="form-group">
              <label for="numberOfLevelsInput">Number of Levels</label>
              <input id="numberOfLevelsInput" type="number" min="1" max="99" value="1" required>
            </div>
            <div class="form-group">
              <label for="projectSizeInput">Project Size (m²)</label>
              <input id="projectSizeInput" type="number" min="100" max="20000" step="10" value="100" required>
            </div>
          </div>
        </div>
        <div class="generate-modal-footer">
          <button type="button" class="secondary" id="generateCancelBtn">Cancel</button>
          <button type="submit" id="generateConfirmBtn">Generate</button>
        </div>
      </form>
    </div>
  </div>

  <div class="delay-modal-backdrop hidden" id="delayModalBackdrop"></div>
  <div class="delay-modal hidden" id="delayModal" role="dialog" aria-modal="true" aria-labelledby="delayModalTitle">
    <div class="delay-modal-content">
      <div class="delay-modal-header">
        <h2 id="delayModalTitle">Delays Schedule</h2>
        <button type="button" class="delay-close-btn" id="closeDelayModalBtn" aria-label="Close delays schedule">×</button>
      </div>
      <div class="delay-modal-body">
        <table class="delay-table">
          <thead>
            <tr>
              <th>Task Name</th>
              <th>Delay Description</th>
              <th>Duration (days)</th>
              <th>Charge to Client</th>
            </tr>
          </thead>
          <tbody id="delayTableBody"></tbody>
        </table>
      </div>
    </div>
  </div>

  <script src="https://alcdn.msauth.net/browser/2.37.0/js/msal-browser.min.js" crossorigin="anonymous"></script>
  <script src="https://res.cdn.office.net/teams-js/v2.17.0/js/MicrosoftTeams.min.js" crossorigin="anonymous"></script>
  <script type="module">
    (async function () {
      const DEFAULT_DAY_WIDTH = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--day-width'), 10) || 32;
      const MIN_ZOOM_SCALE = 0.6;
      const MAX_ZOOM_SCALE = 2.4;
      const ZOOM_STEP = 0.2;
      const ZOOM_TOLERANCE = 0.01;
      let dayWidthScale = 1;
      const MINI_TASK_OPTIONS = ['Bond Bryan Design', 'Bond Bryan review', 'CDP', 'Client Comments', 'Delays', 'Undefined'];
      const DEFAULT_SEQUENCE_STEPS = [
        { name: 'Bond Bryan Design', weight: 50 },
        { name: 'CDP', weight: 10 },
        { name: 'Bond Bryan review', weight: 15 },
        { name: 'Client Comments', weight: 10 },
        { name: 'Bond Bryan review', weight: 15 }
      ];
      const WORKING_DAYS_PER_WEEK = 5;
      const TASK_COLOR_MAP = {
        'Bond Bryan Design': 'rgb(176, 207, 255)',
        'Bond Bryan review': 'rgb(255, 192, 203)',
        'CDP': 'rgb(196, 235, 214)',
        'Client Comments': 'rgb(255, 223, 186)',
        'Delays': 'rgb(220, 220, 230)',
        'Undefined': 'rgb(245, 245, 245)'
      };
      const DEFAULT_SEGMENT_COLOR = '#3056d3';
      // Graph configuration for OneDrive storage
      const CLIENT_ID = '64eaf9c0-93d7-4bda-9f02-b343bc459350';
      const TENANT_ID = '6dc7041f-549e-4127-9e89-36f74513bad5';
      const GRAPH_SCOPES = ['User.Read', 'Files.ReadWrite.All'];
      const GRAPH_BASE_URL = 'https://graph.microsoft.com/v1.0';
      const GRAPH_ITEM_PATH_SEGMENTS = ['Documents', 'Programme App', 'gantt-shared-data.json'];
      const GRAPH_ITEM_PATH = GRAPH_ITEM_PATH_SEGMENTS.map((segment) => encodeURIComponent(segment)).join('/');
      const GRAPH_ITEM_CONTENT_URL = `${GRAPH_BASE_URL}/me/drive/root:/${GRAPH_ITEM_PATH}:/content`;
      const GRAPH_AUTHORITY_PRIMARY = TENANT_ID ? `https://login.microsoftonline.com/${TENANT_ID}` : null;
      const GRAPH_AUTHORITY_FALLBACK = 'https://login.microsoftonline.com/common';
      const GRAPH_REDIRECT_URI = "https://kebbre.github.io/BBProgramme/";
      const TEAMS_AUTH_QUERY_PARAM = 'teamsAuth';
      const TEAMS_AUTH_QUERY_VALUE = '1';
      const TEAMS_AUTH_SESSION_KEY = 'bbprogramme:teams-auth-flow';
      const TEAMS_AUTH_POPUP_WIDTH = 600;
      const TEAMS_AUTH_POPUP_HEIGHT = 535;
      const TEAMS_AUTH_POPUP_URL = `${GRAPH_REDIRECT_URI}?${TEAMS_AUTH_QUERY_PARAM}=${TEAMS_AUTH_QUERY_VALUE}`;
      const currentUrlSearch = new URLSearchParams(window.location.search);
      if (currentUrlSearch.get(TEAMS_AUTH_QUERY_PARAM) === TEAMS_AUTH_QUERY_VALUE) {
        window.sessionStorage.setItem(TEAMS_AUTH_SESSION_KEY, TEAMS_AUTH_QUERY_VALUE);
      }
      const isTeamsAuthWindow = window.sessionStorage.getItem(TEAMS_AUTH_SESSION_KEY) === TEAMS_AUTH_QUERY_VALUE;

      const DATABASE_FALLBACK = [
        {"buildingType":"school","task":"GA Plan","weekdays":10,"squareMeterFactor":0.01,"difficultyFactor":3,"levelsFactor":2},
        {"buildingType":"school","task":"Elevations","weekdays":15,"squareMeterFactor":0.02,"difficultyFactor":5,"levelsFactor":1},
        {"buildingType":"school","task":"Circulation Plans","weekdays":5,"squareMeterFactor":0.03,"difficultyFactor":6,"levelsFactor":2},
        {"buildingType":"Residential tower","task":"GA Plan","weekdays":20,"squareMeterFactor":0.01,"difficultyFactor":2,"levelsFactor":2},
        {"buildingType":"Residential tower","task":"Stairs drawings","weekdays":20,"squareMeterFactor":0.01,"difficultyFactor":3,"levelsFactor":6},
        {"buildingType":"Residential tower","task":"Kitchen layouts","weekdays":5,"squareMeterFactor":0.01,"difficultyFactor":1,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Site Plan Existing","weekdays":2,"squareMeterFactor":0.01,"difficultyFactor":2,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Site Plan Proposed","weekdays":15,"squareMeterFactor":0.01,"difficultyFactor":6,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Kerb Drawings","weekdays":5,"squareMeterFactor":0.01,"difficultyFactor":6,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Site Plan Existing","weekdays":2,"squareMeterFactor":0.01,"difficultyFactor":2,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Site Plan Proposed","weekdays":15,"squareMeterFactor":0.01,"difficultyFactor":6,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Kerb Drawings","weekdays":5,"squareMeterFactor":0.01,"difficultyFactor":6,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Site Plan Existing","weekdays":2,"squareMeterFactor":0.01,"difficultyFactor":2,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Site Plan Proposed","weekdays":15,"squareMeterFactor":0.01,"difficultyFactor":6,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Kerb Drawings","weekdays":5,"squareMeterFactor":0.01,"difficultyFactor":6,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Site Plan Existing","weekdays":2,"squareMeterFactor":0.01,"difficultyFactor":2,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Site Plan Proposed","weekdays":15,"squareMeterFactor":0.01,"difficultyFactor":6,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Kerb Drawings","weekdays":5,"squareMeterFactor":0.01,"difficultyFactor":6,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Site Plan Existing","weekdays":2,"squareMeterFactor":0.01,"difficultyFactor":2,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Site Plan Proposed","weekdays":15,"squareMeterFactor":0.01,"difficultyFactor":6,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Kerb Drawings","weekdays":5,"squareMeterFactor":0.01,"difficultyFactor":6,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Site Plan Existing","weekdays":2,"squareMeterFactor":0.01,"difficultyFactor":2,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Site Plan Proposed","weekdays":15,"squareMeterFactor":0.01,"difficultyFactor":6,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Kerb Drawings","weekdays":5,"squareMeterFactor":0.01,"difficultyFactor":6,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Site Plan Existing","weekdays":2,"squareMeterFactor":0.01,"difficultyFactor":2,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Site Plan Proposed","weekdays":15,"squareMeterFactor":0.01,"difficultyFactor":6,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Kerb Drawings","weekdays":5,"squareMeterFactor":0.01,"difficultyFactor":6,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Site Plan Existing","weekdays":2,"squareMeterFactor":0.01,"difficultyFactor":2,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Site Plan Proposed","weekdays":15,"squareMeterFactor":0.01,"difficultyFactor":6,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Kerb Drawings","weekdays":5,"squareMeterFactor":0.01,"difficultyFactor":6,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Site Plan Existing","weekdays":2,"squareMeterFactor":0.01,"difficultyFactor":2,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Site Plan Proposed","weekdays":15,"squareMeterFactor":0.01,"difficultyFactor":6,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Kerb Drawings","weekdays":5,"squareMeterFactor":0.01,"difficultyFactor":6,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Site Plan Existing","weekdays":2,"squareMeterFactor":0.01,"difficultyFactor":2,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Site Plan Proposed","weekdays":15,"squareMeterFactor":0.01,"difficultyFactor":6,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Kerb Drawings","weekdays":5,"squareMeterFactor":0.01,"difficultyFactor":6,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Site Plan Existing","weekdays":2,"squareMeterFactor":0.01,"difficultyFactor":2,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Site Plan Proposed","weekdays":15,"squareMeterFactor":0.01,"difficultyFactor":6,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Kerb Drawings","weekdays":5,"squareMeterFactor":0.01,"difficultyFactor":6,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Site Plan Existing","weekdays":2,"squareMeterFactor":0.01,"difficultyFactor":2,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Site Plan Proposed","weekdays":15,"squareMeterFactor":0.01,"difficultyFactor":6,"levelsFactor":1},
        {"buildingType":"Landscape","task":"Kerb Drawings","weekdays":5,"squareMeterFactor":0.01,"difficultyFactor":6,"levelsFactor":1},
        
      ];
      const DAY_NAMES = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
      const MONTH_NAMES = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      const DAYS_HEADER_HEIGHT = '7rem';
      const WEEKS_HEADER_HEIGHT = '5.5rem';

      let tasks = [];
      let selectedTaskId = null;
      let draggedTaskId = null;
      let timelineDays = [];
      let timelineRangeStart = null;
      let timelineRangeEnd = null;
      let currentMode = 'create';
      let editingTaskId = null;
      let databaseRecords = [];
      let timelineViewMode = 'days';
      let standdownDateSet = new Set();
      let timelineDayIndexMap = new Map();
      let currentStanddownSegments = [];
      let milestones = [];
      let milestoneDrafts = [];
      let selectedMilestoneId = null;
      let msalInstance = null;
      let msalInitializationPromise = null;
      let graphAccount = null;
      let activeAccountEmail = null;
      let currentAuthority = GRAPH_AUTHORITY_PRIMARY || GRAPH_AUTHORITY_FALLBACK;
      let authorityFallbackActive = !GRAPH_AUTHORITY_PRIMARY;
      let teamsInitializationPromise = null;
      let renderFrameHandle = null;
      let pdfLogoPromise = null;
      let isSyncingScroll = false;

      async function loadPdfLogo() {
        if (!pdfLogoPromise) {
          pdfLogoPromise = (async () => {
            try {
              const response = await fetch('assets/bb-logo.png', { cache: 'no-store' });
              if (!response || !response.ok) throw new Error(`Logo request failed: ${response?.status}`);
              const blob = await response.blob();
              const arrayBuffer = await blob.arrayBuffer();
              const bytes = new Uint8Array(arrayBuffer);
              let binary = '';
              for (let i = 0; i < bytes.length; i += 1) {
                binary += String.fromCharCode(bytes[i]);
              }
              const base64 = btoa(binary);
              const dataUrl = `data:image/png;base64,${base64}`;
              const dimensions = await new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                  resolve({
                    width: img.naturalWidth || img.width || 1,
                    height: img.naturalHeight || img.height || 1
                  });
                };
                img.onerror = (error) => reject(error);
                img.src = dataUrl;
              });
              return { dataUrl, ...dimensions };
            } catch (error) {
              console.warn('Unable to load PDF logo asset.', error);
              return null;
            }
          })();
        }
        return pdfLogoPromise;
      }

      const taskListEl = document.getElementById('taskList');
      const addTaskBtn = document.getElementById('addTaskBtn');
      const removeTaskBtn = document.getElementById('removeTaskBtn');
      const editTaskBtn = document.getElementById('editTaskBtn');
      const moveUpBtn = document.getElementById('moveUpBtn');
      const moveDownBtn = document.getElementById('moveDownBtn');
      const timelineHeaderEl = document.getElementById('timelineHeader');
      const ganttBodyEl = document.getElementById('ganttBody');
      const plannerViewportEl = document.getElementById('plannerViewport');
      const taskListHeaderEl = document.querySelector('.task-list-header');
      const taskListScrollEl = document.querySelector('.task-list-scroll');
      const ganttBodyScrollEl = document.querySelector('.gantt-body-scroll');
      const topBarEl = document.querySelector('.top-bar');
      const modalBackdrop = document.getElementById('modalBackdrop');
      const modalEl = document.getElementById('taskModal');
      const taskForm = document.getElementById('taskForm');
      const modalTitle = document.getElementById('modalTitle');
      const durationPreview = document.getElementById('durationPreview');
      const cancelModalBtn = document.getElementById('cancelModalBtn');
      const miniTaskList = document.getElementById('miniTaskList');
      const modalEntryType = document.getElementById('modalEntryType');
      const modalTaskName = document.getElementById('modalTaskName');
      const modalNameLabel = document.getElementById('modalNameLabel');
      const modalTaskDescription = document.getElementById('modalTaskDescription');
      const modalStagePreset = document.getElementById('modalStagePreset');
      const modalStageCustomName = document.getElementById('modalStageCustomName');
      const progressGroup = document.getElementById('progressGroup');
      const nameGroup = document.getElementById('nameGroup');
      const stagePresetGroup = document.getElementById('stagePresetGroup');
      const stageCustomNameGroup = document.getElementById('stageCustomNameGroup');
      const descriptionGroup = document.getElementById('descriptionGroup');
      const modalStartDate = document.getElementById('modalStartDate');
      const modalStartDateLabel = document.getElementById('modalStartDateLabel');
      const startDateGroup = document.getElementById('startDateGroup');
      const modalEndDate = document.getElementById('modalEndDate');
      const endDateGroup = document.getElementById('endDateGroup');
      const miniTaskSection = document.getElementById('miniTaskSection');
      const modalProgress = document.getElementById('modalTaskProgress');
      const viewModeButtons = Array.from(document.querySelectorAll('.view-mode-btn'));
      const zoomInBtn = document.getElementById('zoomInBtn');
      const zoomOutBtn = document.getElementById('zoomOutBtn');
      const addMiniTaskBtn = document.getElementById('addMiniTaskBtn');
      const removeMiniTaskBtn = document.getElementById('removeMiniTaskBtn');
      const miniUnitButtons = Array.from(document.querySelectorAll('.mini-unit-btn'));
      let miniTaskDrafts = [];
      let miniTaskUnit = 'days';
      let currentEntryType = 'task';
      const STAGE_PRESET_OPTIONS = [
        { value: 'stage1', label: 'Stage 1' },
        { value: 'stage2', label: 'Stage 2' },
        { value: 'stage3', label: 'Stage 3' },
        { value: 'stage4', label: 'Stage 4' },
        { value: 'stage5', label: 'Stage 5' },
        { value: 'stage6', label: 'Stage 6' },
        { value: 'stage7', label: 'Stage 7' },
        { value: 'other', label: 'Other' }
      ];
      const saveTaskBtn = document.getElementById('saveTaskBtn');
      const generateScheduleBtn = document.getElementById('generateScheduleBtn');
      const generateModalBackdrop = document.getElementById('generateModalBackdrop');
      const generateModal = document.getElementById('generateModal');
      const generateForm = document.getElementById('generateForm');
      const generateCancelBtn = document.getElementById('generateCancelBtn');
      const buildingTypeSelect = document.getElementById('buildingTypeSelect');
      const projectDifficultyInput = document.getElementById('projectDifficultyInput');
      const numberOfLevelsInput = document.getElementById('numberOfLevelsInput');
      const projectSizeInput = document.getElementById('projectSizeInput');
      const savePdfBtn = document.getElementById('savePdfBtn');
      const scheduleSettingsBtn = document.getElementById('scheduleSettingsBtn');
      const saveProgrammeBtn = document.getElementById('saveProgrammeBtn');
      const loadProgrammeBtn = document.getElementById('loadProgrammeBtn');
      const delayScheduleBtn = document.getElementById('delayScheduleBtn');
      const graphAuthBtn = document.getElementById('graphAuthBtn');
      const legendContainer = document.getElementById('taskLegend');
      const scheduleModalBackdrop = document.getElementById('scheduleModalBackdrop');
      const scheduleModal = document.getElementById('scheduleModal');
      const addMilestoneBtn = document.getElementById('addMilestoneBtn');
      const removeMilestoneBtn = document.getElementById('removeMilestoneBtn');
      const milestoneListEl = document.getElementById('milestoneList');
      const cancelScheduleBtn = document.getElementById('cancelScheduleBtn');
      const saveScheduleBtn = document.getElementById('saveScheduleBtn');
      const delayModalBackdrop = document.getElementById('delayModalBackdrop');
      const delayModal = document.getElementById('delayModal');
      const closeDelayModalBtn = document.getElementById('closeDelayModalBtn');
      const delayTableBody = document.getElementById('delayTableBody');

      function parseDate(value) {
        if (!value) return null;
        const parts = value.split('-').map(Number);
        if (parts.length !== 3 || parts.some(Number.isNaN)) return null;
        return new Date(Date.UTC(parts[0], parts[1] - 1, parts[2]));
      }
      function updateHeaderOffset() {
        const root = document.documentElement;
        const headerHeight = timelineViewMode === 'weeks' ? WEEKS_HEADER_HEIGHT : DAYS_HEADER_HEIGHT;
        root.style.setProperty('--timeline-header-height', headerHeight);
        root.style.setProperty('--task-header-height', headerHeight);
        if (taskListHeaderEl) {
          taskListHeaderEl.style.height = headerHeight;
          taskListHeaderEl.style.minHeight = headerHeight;
        }
        if (timelineHeaderEl) {
          timelineHeaderEl.style.height = headerHeight;
          timelineHeaderEl.style.minHeight = headerHeight;
        }
      }

      function formatDate(date) {
        return date instanceof Date ? date.toISOString().slice(0, 10) : '';
      }

      function formatDisplayDate(date) {
        if (!(date instanceof Date)) return '';
        return `${MONTH_NAMES[date.getUTCMonth()]} ${String(date.getUTCDate()).padStart(2, '0')}`;
      }

      function formatShortDate(date) {
        if (!(date instanceof Date)) return '';
        const day = String(date.getUTCDate()).padStart(2, '0');
        const month = String(date.getUTCMonth() + 1).padStart(2, '0');
        return `${day}/${month}`;
      }

      function autoResizeTextarea(textarea) {
        if (!textarea) return;
        const applyResize = () => {
          textarea.style.height = 'auto';
          const computed = window.getComputedStyle(textarea);
          const borderHeight = (parseFloat(computed.borderTopWidth) || 0) + (parseFloat(computed.borderBottomWidth) || 0);
          const minHeight = parseFloat(computed.minHeight) || 0;
          const contentHeight = textarea.scrollHeight + borderHeight;
          const nextHeight = Math.max(minHeight, contentHeight);
          textarea.style.height = `${nextHeight}px`;
        };
        if (!textarea.isConnected) {
          requestAnimationFrame(applyResize);
          return;
        }
        applyResize();
      }

      function populateStagePresetOptions() {
        if (!modalStagePreset) return;
        modalStagePreset.innerHTML = '';
        STAGE_PRESET_OPTIONS.forEach((option) => {
          const optionEl = document.createElement('option');
          optionEl.value = option.value;
          optionEl.textContent = option.label;
          modalStagePreset.appendChild(optionEl);
        });
      }

      function stageOptionLabel(value) {
        const found = STAGE_PRESET_OPTIONS.find((option) => option.value === value);
        return found ? found.label : value;
      }

      function mapStagePresetFromLabel(label) {
        if (!label) return STAGE_PRESET_OPTIONS[0].value;
        const normalized = String(label).trim();
        if (!normalized) return STAGE_PRESET_OPTIONS[0].value;
        const directMatch = STAGE_PRESET_OPTIONS.find((option) => option.value === normalized);
        if (directMatch) return directMatch.value;
        const normalizedLower = normalized.toLowerCase();
        const labelMatch = STAGE_PRESET_OPTIONS.find((option) => option.label.toLowerCase() === normalizedLower);
        return labelMatch ? labelMatch.value : 'other';
      }

      function normalizeStageMetadata(stage) {
        const base = stage ? { ...stage } : {};
        base.entryType = 'stage';
        base.isStage = true;
        base.singleEvent = false;
        base.undefinedDuration = 0;
        base.miniTasks = [];
        base.parentId = typeof base.parentId === 'string' && base.parentId.trim()
          ? base.parentId.trim()
          : null;
        const candidateLabel = base.stagePreset || base.stageLabel || base.name;
        let preset = mapStagePresetFromLabel(candidateLabel);
        if (!STAGE_PRESET_OPTIONS.some((option) => option.value === preset)) {
          preset = STAGE_PRESET_OPTIONS[0].value;
        }
        base.stagePreset = preset;
        const presetOption = STAGE_PRESET_OPTIONS.find((option) => option.value === preset) || STAGE_PRESET_OPTIONS[0];
        if (preset === 'other') {
          const customName = typeof base.stageCustomName === 'string'
            ? base.stageCustomName.trim()
            : '';
          const fallbackName = typeof base.name === 'string' ? base.name.trim() : '';
          base.stageCustomName = customName || fallbackName;
          base.name = base.stageCustomName || 'Stage';
        } else {
          base.stageCustomName = '';
          base.name = presetOption.label;
        }
        base.startDate = typeof base.startDate === 'string' ? base.startDate : '';
        base.endDate = typeof base.endDate === 'string' ? base.endDate : '';
        return base;
      }

      function setEntryType(type, options = {}) {
        currentEntryType = type;
        if (modalEntryType && modalEntryType.value !== type) {
          modalEntryType.value = type;
        }
        const isTask = type === 'task';
        const isSingle = type === 'single';
        const isStage = type === 'stage';
        if (progressGroup) progressGroup.style.display = isTask ? '' : 'none';
        if (durationPreview) durationPreview.hidden = isStage;
        if (nameGroup) nameGroup.style.display = isStage ? 'none' : '';
        if (modalTaskName) {
          modalTaskName.required = !isStage;
          modalTaskName.placeholder = isSingle ? 'e.g. Site visit' : 'e.g. Design Development';
          if (isStage) modalTaskName.value = '';
        }
        if (modalNameLabel) {
          modalNameLabel.textContent = isSingle ? 'Event name' : 'Task name';
        }
        if (stagePresetGroup) {
          if (isStage && modalStagePreset && !modalStagePreset.options.length) {
            populateStagePresetOptions();
          }
          stagePresetGroup.style.display = isStage ? '' : 'none';
        }
        if (stageCustomNameGroup) {
          const stageLabel = stageCustomNameGroup.querySelector('label');
          if (stageLabel) stageLabel.textContent = 'Description';
          const showCustom = isStage && modalStagePreset && modalStagePreset.value === 'other';
          stageCustomNameGroup.style.display = showCustom ? '' : 'none';
          if (modalStageCustomName) {
            if (!showCustom) modalStageCustomName.value = '';
            modalStageCustomName.required = showCustom;
          }
        }
        if (descriptionGroup) descriptionGroup.style.display = isStage ? 'none' : '';
        if (startDateGroup) startDateGroup.style.display = isStage ? 'none' : '';
        if (modalStartDate) {
          modalStartDate.required = !isStage;
          if (isStage) modalStartDate.value = '';
        }
        if (modalStartDateLabel) modalStartDateLabel.textContent = isSingle ? 'Date' : 'Start date';
        if (endDateGroup) endDateGroup.style.display = isTask ? '' : 'none';
        if (modalEndDate) {
          if (!isTask) modalEndDate.value = isSingle && modalStartDate ? modalStartDate.value : '';
          modalEndDate.disabled = !isTask;
        }
        if (miniTaskSection) miniTaskSection.style.display = isTask ? '' : 'none';
        if (addMiniTaskBtn) addMiniTaskBtn.disabled = !isTask;
        if (removeMiniTaskBtn) removeMiniTaskBtn.disabled = !isTask || miniTaskDrafts.length === 0;
        miniUnitButtons.forEach((button) => {
          const disabled = !isTask;
          button.disabled = disabled;
          button.setAttribute('aria-disabled', disabled ? 'true' : 'false');
        });
        if (isStage && modalTaskDescription) modalTaskDescription.value = '';
        updateMiniTaskToolbar();
        if (!options.skipPreview) {
          updateDurationPreview();
        }
      }

      function getTodayUtc() {
        const now = new Date();
        return new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
      }

      function isSameUtcDay(a, b) {
        if (!(a instanceof Date) || !(b instanceof Date)) return false;
        return a.getUTCFullYear() === b.getUTCFullYear()
          && a.getUTCMonth() === b.getUTCMonth()
          && a.getUTCDate() === b.getUTCDate();
      }

      function recomputeStanddownSet() {
        standdownDateSet = new Set();
        milestones.forEach((milestone) => {
          if (!milestone || milestone.type !== 'standdown') return;
          const start = parseDate(milestone.startDate);
          const end = parseDate(milestone.endDate);
          if (!start || !end) return;
          let current = new Date(start.getTime());
          const guardLimit = 1500;
          let guard = 0;
          while (compareDates(current, end) <= 0 && guard < guardLimit) {
            standdownDateSet.add(formatDate(current));
            current = addDays(current, 1);
            guard += 1;
          }
        });
      }

      function refreshStanddownLayer(barElement) {
        const layer = barElement.querySelector('.standdown-layer');
        if (!layer) return;
        layer.innerHTML = '';
        const startIndex = Number(barElement.dataset.startIndex);
        const endIndex = Number(barElement.dataset.endIndex);
        if (!Number.isFinite(startIndex) || !Number.isFinite(endIndex)) return;
        const dayWidth = getDayWidth();
        currentStanddownSegments.forEach((segment) => {
          const overlapStart = Math.max(startIndex, segment.startIndex);
          const overlapEnd = Math.min(endIndex, segment.endIndex);
          if (overlapStart > overlapEnd) return;
          const mask = document.createElement('div');
          mask.className = 'standdown-gap';
          mask.style.left = `${(overlapStart - startIndex) * dayWidth}px`;
          mask.style.width = `${(overlapEnd - overlapStart + 1) * dayWidth}px`;
          const rangeStart = timelineDays[overlapStart];
          const rangeEnd = timelineDays[overlapEnd];
          if (rangeStart) {
            const labelPrefix = segment.name ? `${segment.name} • ` : '';
            const dateLabel = overlapStart === overlapEnd
              ? `${formatDisplayDate(rangeStart)}`
              : `${formatDisplayDate(rangeStart)} → ${formatDisplayDate(rangeEnd)}`;
            mask.title = `${labelPrefix}Stand-down ${dateLabel}`;
          }
          layer.appendChild(mask);
        });
      }

      function isStanddownDay(date) {
        if (!(date instanceof Date)) return false;
        return standdownDateSet.has(formatDate(date));
      }

      function isWorkingDay(date) {
        if (!(date instanceof Date)) return false;
        return !isWeekend(date) && !isStanddownDay(date);
      }

      function generateMilestoneId() {
        return `milestone-${Date.now().toString(36)}-${Math.random().toString(16).slice(2, 8)}`;
      }

      function cloneMilestoneList(list) {
        return Array.isArray(list) ? list.map((item) => ({ ...item })) : [];
      }

      function createMilestone(type = 'deadline') {
        const today = formatDate(getTodayUtc());
        return {
          id: generateMilestoneId(),
          name: type === 'standdown' ? 'New stand-down' : 'New deadline',
          type,
          startDate: today,
          endDate: today
        };
      }

      function normalizeMilestoneDates(milestone) {
        if (!milestone) return;
        if (milestone.type !== 'standdown') {
          milestone.endDate = milestone.startDate || milestone.endDate || '';
          return;
        }
        const start = parseDate(milestone.startDate);
        if (!milestone.endDate) milestone.endDate = milestone.startDate || '';
        const end = parseDate(milestone.endDate);
        if (start && end && compareDates(end, start) < 0) {
          milestone.endDate = milestone.startDate;
        }
      }

      function getStageChildren(stageId) {
        return tasks.filter((task) => task.parentId === stageId);
      }

      function detectStagePresetFromName(name) {
        return mapStagePresetFromLabel(name);
      }

      function computeStageSummary(stageTask) {
        if (!stageTask) return { hasChildren: false, start: null, end: null, progress: 0, duration: 0 };
        const children = getStageChildren(stageTask.id).filter((child) => child.entryType !== 'stage');
        if (!children.length) {
          return {
            hasChildren: false,
            start: null,
            end: null,
            progress: 0,
            duration: 0
          };
        }
        let start = null;
        let end = null;
        let totalDuration = 0;
        let weightedProgress = 0;
        children.forEach((child) => {
          const childStart = parseDate(child.startDate);
          const childEnd = parseDate(child.endDate);
          if (childStart) {
            if (!start || compareDates(childStart, start) < 0) start = childStart;
          }
          const effectiveEnd = childEnd || childStart;
          if (effectiveEnd) {
            if (!end || compareDates(effectiveEnd, end) > 0) end = effectiveEnd;
          }
          const duration = Math.max(1, getTaskDuration(child));
          totalDuration += duration;
          const progressValue = Math.min(100, Math.max(0, Number(child.progress) || 0));
          weightedProgress += progressValue * duration;
        });
        const progress = totalDuration ? Math.round(weightedProgress / totalDuration) : 0;
        return {
          hasChildren: true,
          start,
          end,
          progress,
          duration: totalDuration
        };
      }

      function updateStageRowDisplay(stageTask, summary) {
        if (!taskListEl || !stageTask) return;
        const row = taskListEl.querySelector(`.task-row[data-task-id="${stageTask.id}"]`);
        if (!row) return;
        const hasChildren = Boolean(summary && summary.hasChildren);
        row.classList.toggle('stage-empty', !hasChildren);

        const startCell = row.querySelector('.task-start');
        if (startCell) {
          if (hasChildren && stageTask.startDate) {
            startCell.textContent = stageTask.startDate;
            startCell.classList.remove('stage-meta-hidden');
          } else {
            startCell.textContent = '—';
            startCell.classList.add('stage-meta-hidden');
          }
        }

        const endCell = row.querySelector('.task-end');
        if (endCell) {
          if (hasChildren && stageTask.endDate) {
            endCell.textContent = stageTask.endDate;
            endCell.classList.remove('stage-meta-hidden');
          } else {
            endCell.textContent = '—';
            endCell.classList.add('stage-meta-hidden');
          }
        }

        const durationBadge = row.querySelector('.task-duration');
        if (durationBadge) {
          const durationValue = hasChildren
            ? Math.max(0, Math.round((summary && summary.duration) || 0))
            : 0;
          if (durationValue > 0) {
            durationBadge.textContent = `${durationValue} day${durationValue !== 1 ? 's' : ''}`;
          } else {
            durationBadge.textContent = '—';
          }
        }

        const progressCell = row.querySelector('.task-progress');
        if (progressCell) {
          if (hasChildren) {
            const progressValue = Math.min(100, Math.max(0, Math.round(stageTask.progress || 0)));
            progressCell.textContent = `${progressValue}%`;
            progressCell.classList.remove('stage-meta-hidden');
          } else {
            progressCell.textContent = '—';
            progressCell.classList.add('stage-meta-hidden');
          }
        }
      }

      function updateAllStageSummaries() {
        tasks.forEach((task) => {
          if (task.entryType !== 'stage') return;
          const summary = computeStageSummary(task);
          if (!summary.hasChildren) {
            task.startDate = '';
            task.endDate = '';
            task.progress = 0;
            updateStageRowDisplay(task, summary);
            return;
          }
          task.progress = summary.progress;
          task.startDate = summary.start ? formatDate(summary.start) : '';
          task.endDate = summary.end ? formatDate(summary.end) : '';
          updateStageRowDisplay(task, summary);
        });
      }

      function getStageLetterLabel(index) {
        if (typeof index !== 'number' || index < 0) return '';
        let value = Math.floor(index);
        let label = '';
        while (value >= 0) {
          const remainder = value % 26;
          label = String.fromCharCode(65 + remainder) + label;
          value = Math.floor(value / 26) - 1;
        }
        return label;
      }

      function buildTaskIdentifiers(orderedEntries) {
        const identifiers = new Map();
        const stageMeta = new Map();
        let stageIndex = 0;
        let unassignedCounter = 0;
        orderedEntries.forEach((entry) => {
          const task = entry?.task;
          if (!task) return;
          if (task.entryType === 'stage') {
            const letter = getStageLetterLabel(stageIndex);
            stageMeta.set(task.id, { letter, counter: 0 });
            identifiers.set(task.id, letter || '—');
            stageIndex += 1;
            return;
          }
          const parentInfo = stageMeta.get(task.parentId);
          if (parentInfo && parentInfo.letter) {
            parentInfo.counter += 1;
            const sequence = String(parentInfo.counter).padStart(3, '0');
            identifiers.set(task.id, `${parentInfo.letter}-${sequence}`);
            return;
          }
          unassignedCounter += 1;
          const sequence = String(unassignedCounter).padStart(3, '0');
          identifiers.set(task.id, `X-${sequence}`);
        });
        return identifiers;
      }

      function getOrderedTasks() {
        const added = new Set();
        const ordered = [];
        tasks.forEach((task) => {
          if (task.entryType === 'stage') {
            ordered.push({ task, depth: 0 });
            added.add(task.id);
            getStageChildren(task.id).forEach((child) => {
              ordered.push({ task: child, depth: 1 });
              added.add(child.id);
            });
          }
        });
        tasks.forEach((task) => {
          if (added.has(task.id)) return;
          const depth = task.parentId ? 1 : 0;
          ordered.push({ task, depth });
          added.add(task.id);
        });
        return ordered;
      }

      function updateMilestoneSelectionUI() {
        if (!milestoneListEl) return;
        if (!milestoneDrafts.length) {
          selectedMilestoneId = null;
        } else if (!selectedMilestoneId || !milestoneDrafts.some((milestone) => milestone.id === selectedMilestoneId)) {
          selectedMilestoneId = milestoneDrafts[0].id;
        }
        const rows = milestoneListEl.querySelectorAll('.milestone-item');
        rows.forEach((row) => {
          row.classList.toggle('selected', row.dataset.id === selectedMilestoneId);
        });
        if (removeMilestoneBtn) removeMilestoneBtn.disabled = !selectedMilestoneId;
      }

      function renderMilestoneDrafts() {
        if (!milestoneListEl) return;
        milestoneListEl.innerHTML = '';
        if (!milestoneDrafts.length) {
          const empty = document.createElement('div');
          empty.className = 'empty-milestones';
          empty.textContent = 'No milestones yet. Use "＋ Add Milestone" to create one.';
          milestoneListEl.appendChild(empty);
          if (removeMilestoneBtn) removeMilestoneBtn.disabled = true;
          return;
        }
        milestoneDrafts.forEach((milestone) => {
          normalizeMilestoneDates(milestone);
          const item = document.createElement('li');
          item.className = 'milestone-item';
          item.dataset.id = milestone.id;

          item.addEventListener('click', (event) => {
            if (event.target.closest('input') || event.target.closest('select')) return;
            selectedMilestoneId = milestone.id;
            updateMilestoneSelectionUI();
          });

          const nameField = document.createElement('div');
          nameField.className = 'field';
          const nameLabel = document.createElement('label');
          nameLabel.textContent = 'Milestone';
          const nameInput = document.createElement('input');
          nameInput.type = 'text';
          nameInput.value = milestone.name || '';
          nameInput.placeholder = 'e.g. Planning submission';
          nameInput.addEventListener('focus', () => {
            if (selectedMilestoneId !== milestone.id) {
              selectedMilestoneId = milestone.id;
              updateMilestoneSelectionUI();
            }
          });
          nameInput.addEventListener('input', (event) => {
            milestone.name = event.target.value;
          });
          nameField.appendChild(nameLabel);
          nameField.appendChild(nameInput);
          item.appendChild(nameField);

          let endInputRef = null;

          const typeField = document.createElement('div');
          typeField.className = 'field';
          const typeLabel = document.createElement('label');
          typeLabel.textContent = 'Type';
          const typeSelect = document.createElement('select');
          const deadlineOption = document.createElement('option');
          deadlineOption.value = 'deadline';
          deadlineOption.textContent = 'Deadline';
          const standdownOption = document.createElement('option');
          standdownOption.value = 'standdown';
          standdownOption.textContent = 'Stand-down';
          typeSelect.appendChild(deadlineOption);
          typeSelect.appendChild(standdownOption);
          typeSelect.value = milestone.type === 'standdown' ? 'standdown' : 'deadline';
          typeSelect.addEventListener('focus', () => {
            if (selectedMilestoneId !== milestone.id) {
              selectedMilestoneId = milestone.id;
              updateMilestoneSelectionUI();
            }
          });
          typeSelect.addEventListener('change', (event) => {
            milestone.type = event.target.value === 'standdown' ? 'standdown' : 'deadline';
            if (milestone.type !== 'standdown') {
              milestone.endDate = milestone.startDate || milestone.endDate || '';
            }
            renderMilestoneDrafts();
          });
          typeField.appendChild(typeLabel);
          typeField.appendChild(typeSelect);
          item.appendChild(typeField);

          const startField = document.createElement('div');
          startField.className = 'field';
          const startLabel = document.createElement('label');
          startLabel.textContent = milestone.type === 'standdown' ? 'Start date' : 'Date';
          const startInput = document.createElement('input');
          startInput.type = 'date';
          startInput.value = milestone.startDate || '';
          startInput.addEventListener('focus', () => {
            if (selectedMilestoneId !== milestone.id) {
              selectedMilestoneId = milestone.id;
              updateMilestoneSelectionUI();
            }
          });
          startInput.addEventListener('change', (event) => {
            milestone.startDate = event.target.value || '';
            if (milestone.type !== 'standdown') {
              milestone.endDate = milestone.startDate;
            } else {
              normalizeMilestoneDates(milestone);
              if (milestone.endDate && compareDates(parseDate(milestone.endDate), parseDate(milestone.startDate)) < 0) {
                milestone.endDate = milestone.startDate;
              }
              if (endInputRef) {
                endInputRef.value = milestone.endDate || '';
              }
            }
            updateMilestoneSelectionUI();
          });
          startField.appendChild(startLabel);
          startField.appendChild(startInput);
          item.appendChild(startField);

          const endField = document.createElement('div');
          endField.className = 'field';
          const endLabel = document.createElement('label');
          endLabel.textContent = 'End date';
          if (milestone.type === 'standdown') {
            const endInput = document.createElement('input');
            endInput.type = 'date';
            endInput.value = milestone.endDate || '';
            endInputRef = endInput;
            endInput.addEventListener('focus', () => {
              if (selectedMilestoneId !== milestone.id) {
                selectedMilestoneId = milestone.id;
                updateMilestoneSelectionUI();
              }
            });
            endInput.addEventListener('change', (event) => {
              milestone.endDate = event.target.value || '';
              normalizeMilestoneDates(milestone);
              if (endInput.value !== (milestone.endDate || '')) {
                endInput.value = milestone.endDate || '';
              }
              updateMilestoneSelectionUI();
            });
            endField.appendChild(endLabel);
            endField.appendChild(endInput);
          } else {
            const placeholder = document.createElement('div');
            placeholder.className = 'placeholder';
            placeholder.textContent = '—';
            endField.appendChild(endLabel);
            endField.appendChild(placeholder);
          }
          item.appendChild(endField);

          milestoneListEl.appendChild(item);
        });
        updateMilestoneSelectionUI();
      }

      function openScheduleModal() {
        milestoneDrafts = cloneMilestoneList(milestones);
        selectedMilestoneId = milestoneDrafts.length ? milestoneDrafts[0].id : null;
        renderMilestoneDrafts();
        if (scheduleModalBackdrop) scheduleModalBackdrop.classList.remove('hidden');
        if (scheduleModal) scheduleModal.classList.remove('hidden');
        document.body.style.overflow = 'hidden';
      }

      function closeScheduleModal() {
        if (scheduleModalBackdrop) scheduleModalBackdrop.classList.add('hidden');
        if (scheduleModal) scheduleModal.classList.add('hidden');
        document.body.style.overflow = '';
        milestoneDrafts = [];
        selectedMilestoneId = null;
        if (removeMilestoneBtn) removeMilestoneBtn.disabled = true;
      }

      function openGenerateModal() {
        if (!generateModal || !generateModalBackdrop) return;
        generateModalBackdrop.classList.remove('hidden');
        generateModal.classList.remove('hidden');
        document.body.style.overflow = 'hidden';
        if (buildingTypeSelect) {
          requestAnimationFrame(() => buildingTypeSelect.focus());
        }
      }

      function closeGenerateModal() {
        if (!generateModal || !generateModalBackdrop) return;
        generateModalBackdrop.classList.add('hidden');
        generateModal.classList.add('hidden');
        document.body.style.overflow = '';
      }

      function handleSaveScheduleSettings() {
        milestones = cloneMilestoneList(milestoneDrafts).map((milestone) => {
          const normalized = { ...milestone };
          if (normalized.type !== 'standdown') {
            normalized.endDate = normalized.startDate || normalized.endDate || '';
          }
          normalizeMilestoneDates(normalized);
          return normalized;
        });
        recomputeStanddownSet();
        tasks.forEach((task) => {
          ensureTaskDates(task);
        });
        closeScheduleModal();
        renderAll();
      }

      function serialiseProgramme() {
        updateAllStageSummaries();
        return {
          tasks: tasks.map((task) => ({
            ...task,
            miniTasks: Array.isArray(task.miniTasks) ? task.miniTasks.map((mini) => ({ ...mini })) : []
          })),
          milestones: cloneMilestoneList(milestones)
        };
      }

      function applyProgrammeSnapshot(data) {
        if (!data || typeof data !== 'object') throw new Error('Invalid programme format.');
        const loadedTasks = Array.isArray(data.tasks) ? data.tasks : [];
        const loadedMilestones = Array.isArray(data.milestones) ? data.milestones : [];
        tasks = loadedTasks.map((task) => {
          const entryType = task?.entryType || (task?.singleEvent ? 'single' : 'task');
          const parentId = typeof task?.parentId === 'string' && task.parentId ? task.parentId : null;
          if (entryType === 'stage') {
            const normalizedStage = normalizeStageMetadata({
              ...task,
              parentId
            });
            normalizedStage.progress = Math.min(100, Math.max(0, Number(task?.progress) || 0));
            return normalizedStage;
          }
          const undefinedDuration = Math.max(0, Math.round(task?.undefinedDuration || 0));
          const singleEvent = entryType === 'single';
          const miniTasks = entryType === 'task'
            ? (Array.isArray(task.miniTasks)
              ? task.miniTasks.map((mini) => ({
                ...mini,
                locked: Boolean(mini.locked)
              }))
              : [])
            : [];
          return {
            ...task,
            entryType,
            singleEvent,
            undefinedDuration,
            miniTasks,
            parentId,
            stagePreset: '',
            stageCustomName: '',
            isStage: false
          };
        });
        milestones = cloneMilestoneList(loadedMilestones);
        tasks.forEach((task) => {
          if (task.entryType !== 'stage') ensureTaskDates(task);
        });
        recomputeStanddownSet();
        selectedTaskId = null;
        milestoneDrafts = [];
        selectedMilestoneId = null;
        updateAllStageSummaries();
        renderAll();
      }

      function setActiveGraphAccount(account) {
        if (account) {
          graphAccount = account;
          activeAccountEmail = account.username || account.name || '';
        } else {
          graphAccount = null;
          activeAccountEmail = null;
        }
        if (msalInstance && typeof msalInstance.setActiveAccount === 'function') {
          msalInstance.setActiveAccount(account || null);
        }
        updateGraphAuthUI();
      }

      function updateGraphAuthUI() {
        if (!graphAuthBtn) return;
        if (graphAccount) {
          const label = activeAccountEmail ? `Signed in: ${activeAccountEmail}` : 'Signed in';
          graphAuthBtn.textContent = label;
          graphAuthBtn.dataset.signedIn = 'true';
          graphAuthBtn.title = 'Click to sign out from OneDrive';
        } else {
          graphAuthBtn.textContent = 'Sign in to OneDrive';
          delete graphAuthBtn.dataset.signedIn;
          graphAuthBtn.title = 'Click to connect to OneDrive';
        }
      }

      function isTeamsSdkAvailable() {
        return typeof window.microsoftTeams !== 'undefined'
          && typeof window.microsoftTeams?.app?.initialize === 'function';
      }

      async function ensureTeamsAppInitialized() {
        if (!isTeamsSdkAvailable()) {
          throw new Error('Microsoft Teams SDK is not available.');
        }
        if (!teamsInitializationPromise) {
          teamsInitializationPromise = window.microsoftTeams.app.initialize();
        }
        return teamsInitializationPromise;
      }

      async function launchTeamsAuthentication() {
        if (!isTeamsSdkAvailable()) {
          throw new Error('Microsoft Teams SDK is not available.');
        }
        await ensureTeamsAppInitialized();
        const teamsAuth = window.microsoftTeams?.authentication;
        if (!teamsAuth || typeof teamsAuth.authenticate !== 'function') {
          throw new Error('Microsoft Teams authentication capability is unavailable.');
        }
        return new Promise((resolve, reject) => {
          teamsAuth.authenticate({
            url: TEAMS_AUTH_POPUP_URL,
            width: TEAMS_AUTH_POPUP_WIDTH,
            height: TEAMS_AUTH_POPUP_HEIGHT,
            successCallback: (result) => {
              resolve(result);
            },
            failureCallback: (reason) => {
              const message = typeof reason === 'string' && reason.trim().length
                ? reason
                : 'Unknown Teams authentication error.';
              reject(new Error(message));
            }
          });
        });
      }

      async function handleTeamsAuthPopupFlow() {
        if (!isTeamsAuthWindow || !isTeamsSdkAvailable()) {
          return false;
        }
        const teamsAuth = window.microsoftTeams?.authentication;
        if (!teamsAuth
          || typeof teamsAuth.notifySuccess !== 'function'
          || typeof teamsAuth.notifyFailure !== 'function') {
          console.warn('Teams authentication APIs are not available in this context.');
          window.sessionStorage.removeItem(TEAMS_AUTH_SESSION_KEY);
          return false;
        }
        let notifyCompleted = false;
        const notifyFailure = (error) => {
          if (notifyCompleted) return;
          notifyCompleted = true;
          try {
            teamsAuth.notifyFailure(error ?? 'Teams authentication failed.');
          } catch (notifyError) {
            console.error('Unable to notify Teams authentication failure.', notifyError);
          } finally {
            window.sessionStorage.removeItem(TEAMS_AUTH_SESSION_KEY);
          }
        };
        const notifySuccess = (payload) => {
          if (notifyCompleted) return;
          notifyCompleted = true;
          try {
            const serialised = typeof payload === 'string' ? payload : JSON.stringify(payload ?? {});
            teamsAuth.notifySuccess(serialised);
          } catch (notifyError) {
            console.error('Unable to notify Teams authentication success.', notifyError);
            notifyFailure(notifyError instanceof Error ? notifyError.message : String(notifyError));
            return;
          } finally {
            window.sessionStorage.removeItem(TEAMS_AUTH_SESSION_KEY);
          }
        };
        try {
          await ensureTeamsAppInitialized();
        } catch (error) {
          notifyFailure(error instanceof Error ? error.message : String(error));
          return true;
        }
        try {
          await ensureMsalClient();
        } catch (error) {
          notifyFailure(extractErrorMessage(error));
          return true;
        }
        const client = msalInstance;
        try {
          const redirectResult = await client.handleRedirectPromise?.();
          if (redirectResult?.account) {
            setActiveGraphAccount(redirectResult.account);
          }
        } catch (error) {
          console.warn('MSAL redirect handling within Teams auth window failed.', error);
        }
        let account = client.getActiveAccount();
        if (!account) {
          const accounts = client.getAllAccounts();
          if (accounts.length) {
            account = accounts[0];
            setActiveGraphAccount(account);
          }
        }
        if (!account) {
          try {
            window.sessionStorage.setItem(TEAMS_AUTH_SESSION_KEY, TEAMS_AUTH_QUERY_VALUE);
            client.loginRedirect({
              scopes: GRAPH_SCOPES,
              prompt: 'select_account',
              redirectStartPage: window.location.href
            });
            return true;
          } catch (error) {
            notifyFailure(extractErrorMessage(error));
            return true;
          }
        }
        const tokenRequest = { scopes: GRAPH_SCOPES, account };
        try {
          const response = await client.acquireTokenSilent(tokenRequest);
          notifySuccess({
            accessToken: response?.accessToken ?? null,
            account: {
              homeAccountId: account.homeAccountId,
              username: account.username,
              name: account.name
            }
          });
          return true;
        } catch (error) {
          if (window.msal?.InteractionRequiredAuthError && error instanceof window.msal.InteractionRequiredAuthError) {
            try {
              window.sessionStorage.setItem(TEAMS_AUTH_SESSION_KEY, TEAMS_AUTH_QUERY_VALUE);
              client.acquireTokenRedirect({
                ...tokenRequest,
                redirectStartPage: window.location.href
              });
              return true;
            } catch (redirectError) {
              notifyFailure(extractErrorMessage(redirectError));
              return true;
            }
          }
          notifyFailure(extractErrorMessage(error));
          return true;
        }
      }

      function isAuthorityResolutionError(error) {

        const code = error?.errorCode || error?.code || error?.name;
        if (typeof code === 'string' && code.toLowerCase().includes('endpoints_resolution_error')) {
          return true;
        }
        const message = error?.message || error?.errorMessage || '';
        if (typeof message === 'string') {
          const lowered = message.toLowerCase();
          if (lowered.includes('endpoints_resolution_error') || lowered.includes('openid_config_error') || lowered.includes('invalid_tenant')) {
            return true;
          }
        }
        return false;
      }

      async function setupMsalClient(authority, { allowFallback } = { allowFallback: true }) {
        if (!window.msal || !window.msal.PublicClientApplication) {
          throw new Error('Microsoft authentication library is not available.');
        }
        currentAuthority = authority || GRAPH_AUTHORITY_FALLBACK;
        authorityFallbackActive = currentAuthority === GRAPH_AUTHORITY_FALLBACK;
        console.info(`Initialising MSAL with authority: ${currentAuthority}`);
        msalInstance = new window.msal.PublicClientApplication({
          auth: {
            clientId: CLIENT_ID,
            authority: currentAuthority,
            redirectUri: GRAPH_REDIRECT_URI
          },
          cache: {
            cacheLocation: 'localStorage',
            storeAuthStateInCookie: false
          }
        });
        msalInitializationPromise = typeof msalInstance.initialize === 'function'
          ? msalInstance.initialize()
          : Promise.resolve();
        try {
          await msalInitializationPromise;
        } catch (error) {
          if (allowFallback && currentAuthority !== GRAPH_AUTHORITY_FALLBACK && isAuthorityResolutionError(error)) {
            console.warn('Primary authority failed, switching to fallback authority.', error);
            return setupMsalClient(GRAPH_AUTHORITY_FALLBACK, { allowFallback: false });
          }
          throw error;
        }
        setActiveGraphAccount(null);
        const existingAccounts = msalInstance.getAllAccounts();
        if (existingAccounts.length) {
          setActiveGraphAccount(existingAccounts[0]);
        } else {
          updateGraphAuthUI();
        }
        return msalInstance;
      }

      async function runWithAuthorityFallback(executor) {
        try {
          return await executor();
        } catch (error) {
          if (!authorityFallbackActive && isAuthorityResolutionError(error)) {
            console.warn('MSAL operation failed due to authority resolution. Retrying with fallback authority.', error);
            await setupMsalClient(GRAPH_AUTHORITY_FALLBACK, { allowFallback: false });
            return await executor();
          }
          throw error;
        }
      }

      async function ensureMsalClient() {
        if (!msalInstance) {
          await setupMsalClient(GRAPH_AUTHORITY_PRIMARY || GRAPH_AUTHORITY_FALLBACK, { allowFallback: true });
        } else if (msalInitializationPromise) {
          try {
            await msalInitializationPromise;
          } catch (error) {
            if (!authorityFallbackActive && isAuthorityResolutionError(error)) {
              await setupMsalClient(GRAPH_AUTHORITY_FALLBACK, { allowFallback: false });
            } else {
              throw error;
            }
          }
        }
        return msalInstance;
      }

      async function requireGraphAccount({ allowInteractive } = { allowInteractive: false }) {
        return runWithAuthorityFallback(async () => {
          const client = await ensureMsalClient();
          if (graphAccount) return graphAccount;
          const active = client.getActiveAccount();
          if (active) {
            setActiveGraphAccount(active);
            return graphAccount;
          }
          const accounts = client.getAllAccounts();
          if (accounts.length) {
            setActiveGraphAccount(accounts[0]);
            return graphAccount;
          }
          if (!allowInteractive) {
            throw new Error('Please sign in to OneDrive before continuing.');
          }
          if (isTeamsSdkAvailable()) {
            try {
              await launchTeamsAuthentication();
              const refreshedAccount = client.getActiveAccount() || client.getAllAccounts()[0];
              if (refreshedAccount) {
                setActiveGraphAccount(refreshedAccount);
                return graphAccount;
              }
              throw new Error('Teams authentication completed but no account was detected.');
            } catch (teamsError) {
              console.error('Microsoft Teams authentication failed.', teamsError);
              throw teamsError;
            }
          }
          const response = await client.loginPopup({
            scopes: GRAPH_SCOPES,
            prompt: 'select_account'
          });
          setActiveGraphAccount(response.account);
          return graphAccount;
        });
      }

      async function acquireGraphToken({ interactiveFallback = true } = {}) {
        return runWithAuthorityFallback(async () => {
          const client = await ensureMsalClient();
          const account = await requireGraphAccount({ allowInteractive: interactiveFallback });
          const tokenRequest = { scopes: GRAPH_SCOPES, account };
          try {
            const response = await client.acquireTokenSilent(tokenRequest);
            return response.accessToken;
          } catch (error) {
            if (window.msal?.InteractionRequiredAuthError && error instanceof window.msal.InteractionRequiredAuthError) {
              if (!interactiveFallback) throw error;
              const interactiveResponse = await client.acquireTokenPopup(tokenRequest);
              return interactiveResponse.accessToken;
            }
            if (!interactiveFallback) throw error;
            const interactiveResponse = await client.acquireTokenPopup(tokenRequest);
            return interactiveResponse.accessToken;
          }
        });
      }

      async function loginToGraph() {
        try {
          await requireGraphAccount({ allowInteractive: true });
          const label = activeAccountEmail ? `Signed in: ${activeAccountEmail}` : 'Signed in to OneDrive.';
          window.alert(label);
        } catch (error) {
          console.error('Unable to sign in to OneDrive', error);
          window.alert(`Unable to sign in to OneDrive. Details: ${extractErrorMessage(error)}`);
        }
      }

      async function logoutFromGraph() {
        try {
          await runWithAuthorityFallback(async () => {
            const client = await ensureMsalClient();
            if (!graphAccount) {
              updateGraphAuthUI();
              window.alert('No OneDrive session to sign out from.');
              return;
            }
            await client.logoutPopup({ account: graphAccount });
            setActiveGraphAccount(null);
            window.alert('Signed out from OneDrive.');
          });
        } catch (error) {
          console.error('Unable to sign out from OneDrive', error);
          window.alert(`Unable to sign out from OneDrive. Details: ${extractErrorMessage(error)}`);
        }
      }

      async function handleGraphAuthBtnClick() {
        if (!graphAuthBtn) return;
        const signedIn = graphAuthBtn.dataset.signedIn === 'true';
        if (signedIn) {
          await logoutFromGraph();
        } else {
          await loginToGraph();
        }
      }

      async function uploadProgrammeToOneDrive(json) {
        const token = await acquireGraphToken();
        const response = await fetch(GRAPH_ITEM_CONTENT_URL, {
          method: 'PUT',
          headers: {
            Authorization: `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: json
        });
        if (!response.ok) {
          const errorText = await response.text().catch(() => '');
          throw new Error(`Graph upload failed (${response.status}): ${errorText}`);
        }
        return response.json().catch(() => ({}));
      }

      async function downloadProgrammeFromOneDrive() {
        const token = await acquireGraphToken();
        const response = await fetch(GRAPH_ITEM_CONTENT_URL, {
          method: 'GET',
          headers: {
            Authorization: `Bearer ${token}`
          }
        });
        if (!response.ok) {
          const errorText = await response.text().catch(() => '');
          throw new Error(`Graph download failed (${response.status}): ${errorText}`);
        }
        return response.text();
      }

      function extractErrorMessage(error) {
        let message = 'Unknown error.';
        if (!error) {
          message = 'Unknown error.';
        } else if (typeof error === 'string') {
          message = error;
        } else if (error.message) {
          message = error.message;
        } else if (error.errorMessage) {
          message = error.errorMessage;
        } else {
          try {
            message = JSON.stringify(error);
          } catch (jsonError) {
            message = String(error);
          }
        }
        if (currentAuthority) {
          return `${message} [authority: ${currentAuthority}]`;
        }
        return message;
      }

      async function handleSaveProgramme() {
        const payload = serialiseProgramme();
        const json = JSON.stringify(payload, null, 2);
        try {
          await uploadProgrammeToOneDrive(json);
          window.localStorage.setItem('programme-cache', json);
          window.alert('Programme saved to OneDrive.');
        } catch (error) {
          console.error('Unable to save programme to OneDrive', error);
          window.alert(`Unable to save the programme to OneDrive. Details: ${extractErrorMessage(error)}`);
        }
      }

      async function handleLoadProgramme() {
        try {
          const json = await downloadProgrammeFromOneDrive();
          window.localStorage.setItem('programme-cache', json);
          applyProgrammeSnapshot(JSON.parse(json));
          window.alert('Programme loaded from OneDrive.');
        } catch (error) {
          console.warn('Unable to load programme from OneDrive', error);
          try {
            const cached = window.localStorage.getItem('programme-cache');
            if (!cached) throw new Error('No cached programme available.');
            applyProgrammeSnapshot(JSON.parse(cached));
            window.alert('Unable to reach OneDrive. Loaded cached programme instead.');
          } catch (fallbackError) {
            console.error('Unable to load programme', fallbackError);
            window.alert(`Unable to load the programme from OneDrive and no cached version is available. Details: ${extractErrorMessage(error)} | Cache error: ${extractErrorMessage(fallbackError)}`);
          }
        }
      }

      function getDayWidth() {
        const baseWidth = timelineViewMode === 'weeks'
          ? Math.max(1, DEFAULT_DAY_WIDTH / 5)
          : DEFAULT_DAY_WIDTH;
        return Math.max(1, Math.round(baseWidth * dayWidthScale));
      }

      function isWeekend(date) {
        const day = date.getUTCDay();
        return day === 0 || day === 6;
      }

      function addDays(date, days) {
        const result = new Date(date.getTime());
        result.setUTCDate(result.getUTCDate() + days);
        return result;
      }

      function ensureWeekday(date, direction = 1) {
        if (!(date instanceof Date)) return null;
        let result = new Date(date.getTime());
        const step = direction >= 0 ? 1 : -1;
        let guard = 0;
        while (!isWorkingDay(result) && guard < 500) {
          result = addDays(result, step);
          guard += 1;
        }
        return result;
      }

      function shiftWeekdays(date, offset) {
        if (!(date instanceof Date) || offset === 0) return ensureWeekday(date);
        let remaining = Math.abs(offset);
        const direction = offset > 0 ? 1 : -1;
        let current = new Date(date.getTime());
        let guard = 0;
        while (remaining > 0 && guard < 4000) {
          current = addDays(current, direction);
          if (isWorkingDay(current)) remaining -= 1;
          guard += 1;
        }
        return ensureWeekday(current, direction);
      }

      function diffInWeekdays(start, end) {
        if (!start || !end) return 0;
        let from = new Date(start.getTime());
        let to = new Date(end.getTime());
        if (from > to) [from, to] = [to, from];
        let count = 0;
        let current = new Date(from.getTime());
        const guard = 4000;
        let guardCount = 0;
        while (compareDates(current, to) <= 0 && guardCount < guard) {
          if (isWorkingDay(current)) count += 1;
          current = addDays(current, 1);
          guardCount += 1;
        }
        return count;
      }

      function weekdayOffset(from, to) {
        if (!from || !to) return 0;
        const target = ensureWeekday(to, from <= to ? 1 : -1);
        if (!target) return 0;
        if (from.getTime() === target.getTime()) return 0;
        const forward = from < target;
        let steps = 0;
        let cursor = ensureWeekday(from, forward ? 1 : -1);
        const guard = 5000;
        let guardCount = 0;
        while (cursor.getTime() !== target.getTime() && guardCount < guard) {
          cursor = addDays(cursor, forward ? 1 : -1);
          if (isWorkingDay(cursor)) steps += forward ? 1 : -1;
          guardCount += 1;
        }
        return steps;
      }

      function compareDates(a, b) {
        if (!a || !b) return 0;
        const diff = a.getTime() - b.getTime();
        if (diff === 0) return 0;
        return diff > 0 ? 1 : -1;
      }

      function getISOWeekNumber(date) {
        if (!(date instanceof Date)) return 0;
        const tmp = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));
        const dayNum = tmp.getUTCDay() || 7;
        tmp.setUTCDate(tmp.getUTCDate() + 4 - dayNum);
        const yearStart = new Date(Date.UTC(tmp.getUTCFullYear(), 0, 1));
        return Math.ceil((((tmp - yearStart) / 86400000) + 1) / 7);
      }

      function groupTimelineDaysByWeek(days) {
        if (!Array.isArray(days) || !days.length) return [];
        const groups = [];
        days.forEach((day, index) => {
          const weekNumber = getISOWeekNumber(day);
          const year = day.getUTCFullYear();
          const key = `${year}-W${String(weekNumber).padStart(2, '0')}`;
          let group = groups[groups.length - 1];
          if (!group || group.key !== key) {
            group = {
              key,
              year,
              weekNumber,
              start: day,
              end: day,
              length: 1,
              startIndex: index
            };
            groups.push(group);
          } else {
            group.end = day;
            group.length += 1;
          }
        });
        return groups;
      }

      function groupTimelineDaysByMonth(days) {
        if (!Array.isArray(days) || !days.length) return [];
        const groups = [];
        days.forEach((day, index) => {
          const month = day.getUTCMonth();
          const year = day.getUTCFullYear();
          let group = groups[groups.length - 1];
          if (!group || group.month !== month || group.year !== year) {
            group = {
              year,
              month,
              start: day,
              end: day,
              length: 1,
              startIndex: index
            };
            groups.push(group);
          } else {
            group.end = day;
            group.length += 1;
          }
        });
        return groups;
      }

      function groupTimelineDaysByYear(days) {
        if (!Array.isArray(days) || !days.length) return [];
        const groups = [];
        days.forEach((day, index) => {
          const year = day.getUTCFullYear();
          let group = groups[groups.length - 1];
          if (!group || group.year !== year) {
            group = {
              year,
              start: day,
              end: day,
              length: 1,
              startIndex: index
            };
            groups.push(group);
          } else {
            group.end = day;
            group.length += 1;
          }
        });
        return groups;
      }

function adjustGanttOffset() {
  const ganttBody  = document.querySelector('.gantt-body');
  if (!ganttBody) return;
  ganttBody.style.marginTop = '0px';
}


      function updateViewModeButtons() {
        viewModeButtons.forEach((button) => {
          const isActive = button.dataset.viewMode === timelineViewMode;
          button.classList.toggle('active', isActive);
          button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
        });
      }

      function updateZoomControls() {
        if (!zoomInBtn || !zoomOutBtn) return;
        zoomOutBtn.disabled = dayWidthScale <= MIN_ZOOM_SCALE + ZOOM_TOLERANCE;
        zoomInBtn.disabled = dayWidthScale >= MAX_ZOOM_SCALE - ZOOM_TOLERANCE;
      }

      function clampZoom(value) {
        return Math.min(MAX_ZOOM_SCALE, Math.max(MIN_ZOOM_SCALE, value));
      }

      function adjustZoom(delta) {
        const nextScale = clampZoom(dayWidthScale + delta);
        if (Math.abs(nextScale - dayWidthScale) <= ZOOM_TOLERANCE) return;
        dayWidthScale = nextScale;
        renderGantt();
        updateZoomControls();
      }

      function setTimelineViewMode(mode) {
        if (mode !== 'days' && mode !== 'weeks') return;
        if (timelineViewMode === mode) {
          updateHeaderOffset();
          updateStickyMetrics();
          return;
        }
        timelineViewMode = mode;
        updateHeaderOffset();
        updateViewModeButtons();
        renderGantt();
        updateZoomControls();
        updateStickyMetrics();
      }

      function getMiniColor(name) {
        if (!name) return DEFAULT_SEGMENT_COLOR;
        return TASK_COLOR_MAP[name] || DEFAULT_SEGMENT_COLOR;
      }

      function parseColorToRgb(value) {
        if (typeof value !== 'string' || !value) {
          return { r: 48, g: 86, b: 211 };
        }
        const trimmed = value.trim();
        const rgbMatch = trimmed.match(/^rgb\s*\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/i);
        if (rgbMatch) {
          return {
            r: Math.max(0, Math.min(255, parseInt(rgbMatch[1], 10))),
            g: Math.max(0, Math.min(255, parseInt(rgbMatch[2], 10))),
            b: Math.max(0, Math.min(255, parseInt(rgbMatch[3], 10)))
          };
        }
        if (trimmed.startsWith('#')) {
          let hex = trimmed.slice(1);
          if (hex.length === 3) {
            hex = hex.split('').map((char) => char + char).join('');
          }
          if (hex.length === 6 && /^[0-9a-f]{6}$/i.test(hex)) {
            return {
              r: parseInt(hex.slice(0, 2), 16),
              g: parseInt(hex.slice(2, 4), 16),
              b: parseInt(hex.slice(4, 6), 16)
            };
          }
        }
        return { r: 48, g: 86, b: 211 };
      }

      let jsPdfConstructorCache = null;
      let jsPdfLoaderPromise = null;

      function setGlobalJsPdf(ctor) {
        if (!ctor) return;
        if (!window.jspdf) window.jspdf = { jsPDF: ctor };
        else if (typeof window.jspdf.jsPDF !== 'function') window.jspdf.jsPDF = ctor;
      }

      function loadJsPdfFromScript(options) {
        if (window.jspdf && typeof window.jspdf.jsPDF === 'function') {
          return Promise.resolve(window.jspdf.jsPDF);
        }
        const { src, integrity } = options;
        return new Promise((resolve) => {
          const existing = document.querySelector(`script[data-jspdf-source="${src}"]`);
          const finalize = () => {
            const ctor = window.jspdf && typeof window.jspdf.jsPDF === 'function' ? window.jspdf.jsPDF : null;
            if (ctor) setGlobalJsPdf(ctor);
            resolve(ctor);
          };
          const handleError = () => resolve(null);
          if (existing) {
            existing.addEventListener('load', finalize, { once: true });
            existing.addEventListener('error', handleError, { once: true });
            return;
          }
          const script = document.createElement('script');
          script.src = src;
          script.async = true;
          script.dataset.jspdfSource = src;
          script.referrerPolicy = 'no-referrer';
          if (integrity) {
            script.integrity = integrity;
            script.crossOrigin = 'anonymous';
          }
          script.addEventListener('load', finalize, { once: true });
          script.addEventListener('error', handleError, { once: true });
          document.head.appendChild(script);
        });
      }

      async function loadJsPdfFallbacks() {
        const sources = [
          {
            src: 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js',
            integrity: 'sha512-2JvIUMI5KOZ6+Jo7oBMnp1vOSfQ1+avG4v8M45bNaMdWOh9fvydMBaTlM3Dd3yXTVzTuvq8rqBiTWLY4dTqHOg=='
          },
          {
            src: 'https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js'
          }
        ];
        for (let index = 0; index < sources.length; index += 1) {
          const ctor = await loadJsPdfFromScript(sources[index]);
          if (typeof ctor === 'function') return ctor;
        }
        return null;
      }

      async function ensureJsPdfLoaded() {
        if (jsPdfConstructorCache) return jsPdfConstructorCache;
        if (window.jspdf && typeof window.jspdf.jsPDF === 'function') {
          jsPdfConstructorCache = window.jspdf.jsPDF;
          return jsPdfConstructorCache;
        }
        if (jsPdfLoaderPromise) return jsPdfLoaderPromise;
        jsPdfLoaderPromise = import('https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.es.min.js')
          .then((module) => {
            const ctor = module?.jsPDF || module?.default || (window.jspdf && window.jspdf.jsPDF);
            if (typeof ctor === 'function') {
              jsPdfConstructorCache = ctor;
              setGlobalJsPdf(ctor);
            }
            return jsPdfConstructorCache;
          })
          .catch(async (error) => {
            console.error('Failed to load jsPDF ESM bundle', error);
            const fallbackCtor = await loadJsPdfFallbacks();
            if (typeof fallbackCtor === 'function') {
              jsPdfConstructorCache = fallbackCtor;
              setGlobalJsPdf(fallbackCtor);
            }
            return jsPdfConstructorCache;
          })
          .finally(() => {
            jsPdfLoaderPromise = null;
          });
        return jsPdfLoaderPromise;
      }

      function countEnabledMiniTasks(task) {
        if (task?.singleEvent) return 0;
        return (task.miniTasks || []).filter((mini) => mini.enabled).length;
      }

      function minimumTaskDuration(task) {
        if (task?.singleEvent) return 1;
        return Math.max(1, countEnabledMiniTasks(task));
      }

      function normalizeMiniDurations(miniTasks, totalDuration, options = {}) {
        const result = {
          undefinedDuration: Math.max(0, Math.round(options.undefinedDuration || 0))
        };
        const safeTotal = Math.max(0, Math.round(totalDuration || 0));
        if (!Array.isArray(miniTasks) || miniTasks.length === 0) {
          result.undefinedDuration = safeTotal;
          return result;
        }
        const enabled = miniTasks.filter((mini) => mini.enabled);
        if (!enabled.length) {
          result.undefinedDuration = safeTotal;
          return result;
        }
        enabled.forEach((mini) => {
          const rounded = Math.max(1, Math.round(mini.duration || 1));
          mini.duration = rounded;
          mini.locked = Boolean(mini.locked);
        });

        const sumDurations = enabled.reduce((sum, mini) => sum + mini.duration, 0);
        let accounted = sumDurations + result.undefinedDuration;
        if (accounted === safeTotal) {
          return result;
        }

        if (accounted < safeTotal) {
          let deficit = safeTotal - accounted;
          const adjustable = enabled.filter((mini) => !mini.locked);
          if (adjustable.length) {
            adjustable[adjustable.length - 1].duration += deficit;
          } else {
            result.undefinedDuration += deficit;
          }
          return result;
        }

        // accounted > safeTotal
        let excess = accounted - safeTotal;
        if (result.undefinedDuration > 0) {
          const consume = Math.min(result.undefinedDuration, excess);
          result.undefinedDuration -= consume;
          excess -= consume;
        }
        if (excess <= 0) {
          return result;
        }

        const trimDurations = (list) => {
          for (let idx = list.length - 1; idx >= 0 && excess > 0; idx -= 1) {
            const candidate = list[idx];
            const reducible = Math.max(0, candidate.duration - 1);
            if (reducible <= 0) continue;
            const deduction = Math.min(reducible, excess);
            candidate.duration -= deduction;
            excess -= deduction;
          }
        };

        const unlocked = enabled.filter((mini) => !mini.locked);
        if (unlocked.length) {
          trimDurations(unlocked);
        }

        if (excess > 0) {
          trimDurations(enabled);
        }

        // If excess still remains, the schedule is saturated at minimum durations.
        // We keep the remaining overflow so callers can expand overall duration if needed.
        return result;
      }
      function buildMiniSegments(task) {
        if (task?.singleEvent) return [];
        const totalDuration = getTaskDuration(task);
        const clones = task.miniTasks.map((mini, index) => ({ ...mini, __sourceIndex: index }));
        const { undefinedDuration } = normalizeMiniDurations(clones, totalDuration, {
          undefinedDuration: Math.max(0, Math.round(task?.undefinedDuration || 0))
        });
        const segments = clones.filter((mini) => mini.enabled).map((mini) => ({
          ...mini,
          sourceIndex: mini.__sourceIndex
        }));
        if (undefinedDuration > 0) {
          segments.push({
            id: `${task.id || 'task'}-undefined`,
            enabled: true,
            name: 'Undefined',
            duration: undefinedDuration,
            locked: false,
            isUndefined: true,
            sourceIndex: -1
          });
        }
        return segments;
      }

      function sanitiseUndefinedDuration(value) {
        return Math.max(0, Math.round(value || 0));
      }

      function computeMiniDurationSum(miniTasks) {
        return miniTasks
          .filter((mini) => mini.enabled)
          .reduce((sum, mini) => {
            const rounded = Math.max(1, Math.round(mini.duration || 1));
            mini.duration = rounded;
            return sum + rounded;
          }, 0);
      }

      function reconcileMiniDurationsForTask(task, totalDuration, options = {}) {
        if (task?.singleEvent) {
          const start = ensureWeekday(parseDate(task.startDate) || new Date(), 1);
          const normalized = formatDate(start);
          task.startDate = normalized;
          task.endDate = normalized;
          task.miniTasks = [];
          task.undefinedDuration = 0;
          return 1;
        }
        const settings = {
          anchor: options.anchor === 'end' ? 'end' : 'start',
          referenceStart: options.referenceStart instanceof Date ? options.referenceStart : null,
          referenceEnd: options.referenceEnd instanceof Date ? options.referenceEnd : null
        };
        const safeTotal = Math.max(1, Math.round(totalDuration || 1));
        const { undefinedDuration } = normalizeMiniDurations(task.miniTasks, safeTotal, {
          undefinedDuration: sanitiseUndefinedDuration(task?.undefinedDuration || 0)
        });
        task.undefinedDuration = sanitiseUndefinedDuration(undefinedDuration);
        const enabledDuration = computeMiniDurationSum(task.miniTasks);
        const actualDuration = Math.max(1, enabledDuration + task.undefinedDuration);
        if (settings.anchor === 'end' && settings.referenceEnd) {
          const anchoredEnd = ensureWeekday(new Date(settings.referenceEnd.getTime()), -1);
          const adjustedStart = shiftWeekdays(anchoredEnd, -(actualDuration - 1));
          task.startDate = formatDate(adjustedStart);
          task.endDate = formatDate(anchoredEnd);
        } else {
          const anchorStart = settings.referenceStart || parseDate(task.startDate) || ensureWeekday(new Date(), 1);
          const adjustedStart = ensureWeekday(new Date(anchorStart.getTime()), 1);
          const adjustedEnd = shiftWeekdays(adjustedStart, actualDuration - 1);
          task.startDate = formatDate(adjustedStart);
          task.endDate = formatDate(adjustedEnd);
        }
        return actualDuration;
      }

      function buildMiniSegmentsPreview(task, duration) {
        if (task?.singleEvent) return [];
        const clones = task.miniTasks.map((mini, index) => ({ ...mini, __sourceIndex: index }));
        const { undefinedDuration } = normalizeMiniDurations(clones, duration, {
          undefinedDuration: Math.max(0, Math.round(task?.undefinedDuration || 0))
        });
        const segments = clones.filter((mini) => mini.enabled).map((mini) => ({
          ...mini,
          sourceIndex: mini.__sourceIndex
        }));
        if (undefinedDuration > 0) {
          segments.push({
            id: `${task.id || 'task'}-undefined`,
            enabled: true,
            name: 'Undefined',
            duration: undefinedDuration,
            locked: false,
            isUndefined: true,
            sourceIndex: -1
          });
        }
        return segments;
      }

      function getTaskDuration(task) {
        const start = parseDate(task.startDate);
        const end = parseDate(task.endDate);
        if (!start || !end) return 0;
        return Math.max(1, diffInWeekdays(start, end));
      }

      function ensureTaskDates(task) {
        if (task?.singleEvent) {
          const start = ensureWeekday(parseDate(task.startDate) || new Date(), 1);
          const normalized = formatDate(start);
          task.startDate = normalized;
          task.endDate = normalized;
          task.miniTasks = [];
          task.undefinedDuration = 0;
          return;
        }
        let start = ensureWeekday(parseDate(task.startDate) || new Date(), 1);
        let end = ensureWeekday(parseDate(task.endDate) || new Date(start.getTime()), -1);
        if (compareDates(end, start) < 0) {
          end = new Date(start.getTime());
        }
        let duration = Math.max(1, diffInWeekdays(start, end));
        const minDuration = minimumTaskDuration(task);
        if (duration < minDuration) {
          end = shiftWeekdays(start, minDuration - 1);
          duration = diffInWeekdays(start, end);
        }
        reconcileMiniDurationsForTask(task, duration, { anchor: 'start', referenceStart: start });
      }

      function renderTaskList() {
        const previousScrollTop = taskListScrollEl ? taskListScrollEl.scrollTop : 0;
        taskListEl.innerHTML = '';
        const orderedEntries = getOrderedTasks();
        const identifierMap = buildTaskIdentifiers(orderedEntries);
        if (!orderedEntries.length) {
          const empty = document.createElement('div');
          empty.className = 'empty-state';
          empty.textContent = 'Add a task to populate the planner.';
          taskListEl.appendChild(empty);
          if (taskListScrollEl) taskListScrollEl.scrollTop = 0;
          return;
        }
        orderedEntries.forEach(({ task, depth }) => {
          const isStage = task.entryType === 'stage';
          const hasStageChildren = isStage
            ? getStageChildren(task.id).some((child) => child.entryType !== 'stage')
            : false;
          const row = document.createElement('div');
          row.className = 'task-row';
          row.dataset.taskId = task.id;
          row.dataset.entryType = task.entryType || 'task';
          row.dataset.parentId = task.parentId || '';
          if (task.id === selectedTaskId) row.classList.add('selected');
          if (isStage) row.classList.add('stage-row');
          if (isStage && !hasStageChildren) row.classList.add('stage-empty');
          if (!isStage && depth > 0) row.classList.add('stage-child');

          row.draggable = true;
          row.addEventListener('dragstart', (event) => {
            if (event.target && event.target.closest('input, textarea, select')) {
              event.preventDefault();
              return;
            }
            draggedTaskId = task.id;
            row.classList.add('dragging');
            if (event.dataTransfer) {
              event.dataTransfer.effectAllowed = 'move';
              try {
                event.dataTransfer.setData('text/plain', task.id);
              } catch (error) {
                // ignore dataTransfer errors
              }
            }
          });
          row.addEventListener('dragend', () => {
            row.classList.remove('dragging');
            row.classList.remove('drag-over');
            draggedTaskId = null;
          });
          row.addEventListener('dragover', (event) => {
            event.preventDefault();
            const sourceId = draggedTaskId || (event.dataTransfer ? event.dataTransfer.getData('text/plain') : null);
            if (!sourceId || sourceId === task.id) return;
            row.classList.add('drag-over');
            if (event.dataTransfer) event.dataTransfer.dropEffect = 'move';
          });
          row.addEventListener('dragleave', () => {
            row.classList.remove('drag-over');
          });
          row.addEventListener('drop', (event) => {
            event.preventDefault();
            const sourceId = draggedTaskId || (event.dataTransfer ? event.dataTransfer.getData('text/plain') : null);
            row.classList.remove('drag-over');
            if (!sourceId || sourceId === task.id) return;
            const bounds = row.getBoundingClientRect();
            const insertAfter = (event.clientY - bounds.top) > (bounds.height / 2);
            moveTaskRelative(sourceId, task.id, insertAfter);
          });

          const identifierCell = document.createElement('div');
          identifierCell.className = 'task-identifier';
          const identifierValue = identifierMap.get(task.id) || '—';
          identifierCell.textContent = identifierValue;
          if (identifierValue === '—') identifierCell.classList.add('identifier-placeholder');
          row.dataset.identifier = identifierValue;
          row.appendChild(identifierCell);

          const nameCell = document.createElement('div');
          nameCell.className = 'task-name';
          nameCell.textContent = task.name || (isStage ? 'Stage' : 'Untitled');
          row.appendChild(nameCell);

          const startCell = document.createElement('div');
          startCell.className = 'task-start';
          if (isStage) {
            startCell.textContent = hasStageChildren && task.startDate ? task.startDate : '—';
            if (!hasStageChildren) startCell.classList.add('stage-meta-hidden');
          } else {
            const startInput = document.createElement('input');
            startInput.type = 'date';
            startInput.value = task.startDate || '';
            startInput.addEventListener('click', (event) => event.stopPropagation());
            startInput.addEventListener('change', (event) => {
              event.stopPropagation();
              const newStart = ensureWeekday(parseDate(event.target.value), 1);
              if (!newStart) {
                event.target.value = task.startDate || '';
                return;
              }
              updateTaskStartDate(task, newStart);
              renderAll();
            });
            startCell.appendChild(startInput);
          }
          row.appendChild(startCell);

          const endCell = document.createElement('div');
          endCell.className = 'task-end';
          if (isStage) {
            endCell.textContent = hasStageChildren && task.endDate ? task.endDate : '—';
            if (!hasStageChildren) endCell.classList.add('stage-meta-hidden');
          } else {
            const endInput = document.createElement('input');
            endInput.type = 'date';
            endInput.value = task.endDate || '';
            endInput.addEventListener('click', (event) => event.stopPropagation());
            endInput.addEventListener('change', (event) => {
              event.stopPropagation();
              const newEnd = ensureWeekday(parseDate(event.target.value), -1);
              if (!newEnd) {
                event.target.value = task.endDate || '';
                return;
              }
              updateTaskEndDate(task, newEnd);
              renderAll();
            });
            endCell.appendChild(endInput);
          }
          row.appendChild(endCell);

          const durationCell = document.createElement('div');
          durationCell.className = 'task-duration-cell';
          const badge = document.createElement('div');
          badge.className = 'task-duration';
          if (isStage) {
            const stageDuration = hasStageChildren && task.startDate && task.endDate ? getTaskDuration(task) : 0;
            badge.textContent = stageDuration
              ? `${stageDuration} day${stageDuration !== 1 ? 's' : ''}`
              : '—';
          } else {
            const duration = getTaskDuration(task);
            badge.textContent = task.singleEvent
              ? 'Single event'
              : `${duration} day${duration !== 1 ? 's' : ''}`;
          }
          durationCell.appendChild(badge);
          row.appendChild(durationCell);

          const progressCell = document.createElement('div');
          progressCell.className = 'task-progress';
          if (isStage) {
            const progressValue = Math.min(100, Math.max(0, Math.round(task.progress || 0)));
            progressCell.textContent = hasStageChildren ? `${progressValue}%` : '—';
            if (!hasStageChildren) progressCell.classList.add('stage-meta-hidden');
          } else {
            const progressInput = document.createElement('input');
            progressInput.type = 'number';
            progressInput.min = '0';
            progressInput.max = '100';
            progressInput.step = '1';
            progressInput.value = Math.min(100, Math.max(0, Number(task.progress) || 0));
            progressInput.addEventListener('click', (event) => event.stopPropagation());
            progressInput.addEventListener('change', (event) => {
              event.stopPropagation();
              let value = parseInt(event.target.value, 10);
              if (Number.isNaN(value)) value = 0;
              task.progress = Math.min(100, Math.max(0, value));
              event.target.value = task.progress;
              updateAllStageSummaries();
              renderGantt();
            });
            const percentLabel = document.createElement('span');
            percentLabel.textContent = '%';
            progressCell.appendChild(progressInput);
            progressCell.appendChild(percentLabel);
          }
          row.appendChild(progressCell);

          row.addEventListener('click', () => {
            selectTask(task.id);
          });

          taskListEl.appendChild(row);
        });
        if (taskListScrollEl) {
          taskListScrollEl.scrollTop = previousScrollTop;
        }
      }
      function computeTimelineRange() {
        if (!tasks.length) {
          const today = ensureWeekday(new Date(), 1);
          return {
            start: shiftWeekdays(today, -7),
            end: shiftWeekdays(today, 14)
          };
        }
        let minStart = parseDate(tasks[0].startDate);
        let maxEnd = parseDate(tasks[0].endDate);
        tasks.forEach((task) => {
          const start = parseDate(task.startDate);
          const end = parseDate(task.endDate);
          if (start && start < minStart) minStart = start;
          if (end && end > maxEnd) maxEnd = end;
        });
        minStart = ensureWeekday(minStart, -1);
        maxEnd = ensureWeekday(maxEnd, 1);
        return {
          start: shiftWeekdays(minStart, -5),
          end: shiftWeekdays(maxEnd, 7)
        };
      }

      function buildTimelineDays(start, end) {
        const days = [];
        let current = new Date(start.getTime());
        const guard = 2000;
        let guardCount = 0;
        while (compareDates(current, end) <= 0 && guardCount < guard) {
          if (!isWeekend(current)) {
            days.push(new Date(current.getTime()));
          }
          current = addDays(current, 1);
          guardCount += 1;
        }
        return days;
      }

      function buildMilestoneSegments(days) {
        if (!Array.isArray(days) || !days.length || !milestones.length) return [];
        const segments = [];
        const timelineStart = days[0];
        const timelineEnd = days[days.length - 1];
        milestones.forEach((milestone) => {
          if (!milestone) return;
          const rawStart = parseDate(milestone.startDate);
          if (!rawStart) return;
          const isStanddown = milestone.type === 'standdown';
          let rawEnd = isStanddown ? parseDate(milestone.endDate) : rawStart;
          if (!rawEnd || compareDates(rawEnd, rawStart) < 0) rawEnd = rawStart;
          if (compareDates(rawStart, timelineEnd) > 0) return;
          if (compareDates(rawEnd, timelineStart) < 0) return;
          let startIndex = -1;
          for (let i = 0; i < days.length; i += 1) {
            if (compareDates(days[i], rawStart) >= 0) {
              startIndex = i;
              break;
            }
          }
          if (startIndex === -1) return;
          let endIndex = startIndex;
          for (let i = startIndex; i < days.length; i += 1) {
            if (compareDates(days[i], rawEnd) > 0) break;
            endIndex = i;
          }
          if (endIndex < startIndex) return;
          segments.push({
            id: milestone.id,
            name: milestone.name || '',
            type: isStanddown ? 'standdown' : 'deadline',
            startIndex,
            endIndex
          });
        });
        return segments;
      }

      function createMiniSegmentElement() {
        const element = document.createElement('div');
        element.className = 'mini-segment mini-control';
        const handleLeft = document.createElement('div');
        handleLeft.className = 'mini-handle mini-handle-left mini-control';
        handleLeft.dataset.edge = 'left';
        handleLeft.setAttribute('role', 'button');
        handleLeft.setAttribute('tabindex', '-1');
        const handleRight = document.createElement('div');
        handleRight.className = 'mini-handle mini-handle-right mini-control';
        handleRight.dataset.edge = 'right';
        handleRight.setAttribute('role', 'button');
        handleRight.setAttribute('tabindex', '-1');
        element.appendChild(handleLeft);
        element.appendChild(handleRight);
        return element;
      }

      function bindMiniSegmentEvents(element, segment, task, barElement, segments, index) {
        if (element._miniCleanup) {
          element._miniCleanup();
          element._miniCleanup = null;
        }
        if (!task || !segment || segment.isUndefined) {
          element.removeAttribute('aria-label');
          element.removeAttribute('aria-pressed');
          element.removeAttribute('role');
          element.removeAttribute('tabindex');
          element.querySelectorAll('.mini-handle').forEach((handle) => {
            handle.classList.add('disabled');
          });
          return;
        }
        const cleanups = [];
        const accessibleLabel = segment.locked ? 'Unlock mini-task length' : 'Lock mini-task length';
        element.setAttribute('role', 'button');
        element.setAttribute('tabindex', '0');
        element.setAttribute('aria-label', accessibleLabel);
        element.setAttribute('aria-pressed', segment.locked ? 'true' : 'false');
        const onClick = (event) => {
          if (event.target.closest('.mini-handle')) return;
          event.preventDefault();
          event.stopPropagation();
          toggleMiniSegmentLock(task, segment.id);
        };
        element.addEventListener('click', onClick);
        cleanups.push(() => element.removeEventListener('click', onClick));
        const onKeyDown = (event) => {
          if (event.key !== 'Enter' && event.key !== ' ') return;
          event.preventDefault();
          event.stopPropagation();
          toggleMiniSegmentLock(task, segment.id);
        };
        element.addEventListener('keydown', onKeyDown);
        cleanups.push(() => element.removeEventListener('keydown', onKeyDown));
        const previousEnabled = (() => {
          if (index <= 0) return null;
          for (let i = index - 1; i >= 0; i -= 1) {
            const candidate = segments[i];
            if (candidate && !candidate.isUndefined) return candidate;
          }
          return null;
        })();
        element.querySelectorAll('.mini-handle').forEach((handle) => {
          const edge = handle.dataset.edge || 'right';
          const needsNeighbor = edge === 'left';
          if (segment.locked || (needsNeighbor && !previousEnabled)) {
            handle.classList.add('disabled');
            return;
          }
          handle.classList.remove('disabled');
          const onPointerDown = (event) => {
            beginMiniSegmentResize(event, task, segment.id, barElement, edge, previousEnabled?.id || null);
          };
          handle.addEventListener('pointerdown', onPointerDown);
          cleanups.push(() => handle.removeEventListener('pointerdown', onPointerDown));
        });
        element._miniCleanup = () => {
          cleanups.forEach((fn) => fn());
        };
      }

      function updateMiniLayerElements(barElement, segments, options = {}) {
        const miniLayer = barElement.querySelector('.mini-layer');
        if (!miniLayer) return;
        const interactive = options.interactive !== false;
        const task = options.task || null;
        const dayWidth = getDayWidth();
        const startIndex = Number(barElement.dataset.startIndex);
        const endIndex = Number(barElement.dataset.endIndex);
        if (!Number.isFinite(startIndex) || !Number.isFinite(endIndex)) return;
        const workingDayIndices = [];
        for (let index = startIndex; index <= endIndex; index += 1) {
          const day = timelineDays[index];
          if (!isStanddownDay(day)) workingDayIndices.push(index);
        }

        while (miniLayer.children.length < segments.length) {
          miniLayer.appendChild(createMiniSegmentElement());
        }

        if (!interactive) {
          miniLayer.querySelectorAll('.mini-segment').forEach((element) => {
            if (element._miniCleanup) {
              element._miniCleanup();
              element._miniCleanup = null;
            }
          });
        }

        const miniElements = Array.from(miniLayer.querySelectorAll('.mini-segment'));
        let workingPointer = 0;
        segments.forEach((segment, index) => {
          const element = miniElements[index];
          if (!element) return;
          const startWorkingIndex = workingDayIndices[workingPointer];
          const requiredSpan = Math.max(1, Math.round(segment.duration || 1));
          const segmentEndWorkingIndex = workingDayIndices[Math.min(
            workingPointer + Math.max(0, requiredSpan - 1),
            workingDayIndices.length - 1
          )];
          if (startWorkingIndex == null || segmentEndWorkingIndex == null || segmentEndWorkingIndex < startWorkingIndex) {
            element.style.display = 'none';
            return;
          }
          const left = (startWorkingIndex - startIndex) * dayWidth;
          const width = ((segmentEndWorkingIndex - startWorkingIndex) + 1) * dayWidth;
          element.style.display = 'block';
          element.style.left = `${left}px`;
          element.style.width = `${width}px`;
          element.dataset.segmentId = segment.id || '';
          element.dataset.sourceIndex = Number.isFinite(segment.sourceIndex) ? String(segment.sourceIndex) : '';
          const isUndefinedSegment = Boolean(segment.isUndefined || segment.name === 'Undefined');
          element.classList.toggle('locked', Boolean(segment.locked));
          element.classList.toggle('undefined', isUndefinedSegment);
          const segmentLabel = `${segment.name || 'Step'} • ${requiredSpan} day${requiredSpan !== 1 ? 's' : ''}`;
          if (!isUndefinedSegment && segment.name === 'Delays') {
            const description = typeof segment.delayDescription === 'string'
              ? segment.delayDescription.trim()
              : '';
            element.title = description || segmentLabel;
          } else {
            element.title = segmentLabel;
          }
          const segmentColor = getMiniColor(segment.name);
          element.style.background = segmentColor;
          const accessibleLabel = segment.locked ? 'Unlock mini-task length' : 'Lock mini-task length';
          if (isUndefinedSegment) {
            element.removeAttribute('aria-label');
            element.removeAttribute('aria-pressed');
            element.removeAttribute('role');
            element.removeAttribute('tabindex');
          } else {
            element.setAttribute('aria-label', accessibleLabel);
            element.setAttribute('aria-pressed', segment.locked ? 'true' : 'false');
            if (interactive) {
              element.setAttribute('role', 'button');
              element.setAttribute('tabindex', '0');
            } else {
              element.removeAttribute('role');
              element.removeAttribute('tabindex');
            }
          }
          element.querySelectorAll('.mini-handle').forEach((handleEl) => {
            const isDisabled = Boolean(segment.locked || isUndefinedSegment);
            handleEl.classList.toggle('disabled', isDisabled);
          });
          if (interactive && task && !isUndefinedSegment) {
            bindMiniSegmentEvents(element, segment, task, barElement, segments, index);
            element.dataset.boundSegmentId = segment.id || '';
          }
          workingPointer += requiredSpan;
        });

        for (let i = segments.length; i < miniElements.length; i += 1) {
          const element = miniElements[i];
          if (!element) continue;
          if (interactive && element._miniCleanup) {
            element._miniCleanup();
            element._miniCleanup = null;
          }
          element.style.display = 'none';
          element.dataset.segmentId = '';
          element.dataset.boundSegmentId = '';
        }
      }

      function toggleMiniSegmentLock(task, segmentId) {
        if (!task || !segmentId) return;
        const target = task.miniTasks.find((mini) => mini.id === segmentId);
        if (!target || !target.enabled) return;
        target.locked = !target.locked;
        selectedTaskId = task.id;
        renderAll();
      }

      function findNearestDonor(enabledSegments, targetIndex) {
        for (let offset = 1; offset < enabledSegments.length; offset += 1) {
          const rightIndex = targetIndex + offset;
          if (rightIndex < enabledSegments.length) {
            const candidate = enabledSegments[rightIndex];
            const current = Math.max(1, Math.round(candidate.duration || 1));
            if (!candidate.locked && current > 1) return candidate;
          }
          const leftIndex = targetIndex - offset;
          if (leftIndex >= 0) {
            const candidate = enabledSegments[leftIndex];
            const current = Math.max(1, Math.round(candidate.duration || 1));
            if (!candidate.locked && current > 1) return candidate;
          }
        }
        return null;
      }

      function findNearestRecipient(enabledSegments, targetIndex) {
        for (let offset = 1; offset < enabledSegments.length; offset += 1) {
          const rightIndex = targetIndex + offset;
          if (rightIndex < enabledSegments.length) {
            const candidate = enabledSegments[rightIndex];
            if (!candidate.locked) return candidate;
          }
          const leftIndex = targetIndex - offset;
          if (leftIndex >= 0) {
            const candidate = enabledSegments[leftIndex];
            if (!candidate.locked) return candidate;
          }
        }
        return null;
      }

      function adjustMiniDurationStep(state, segmentId, direction) {
        const enabled = state.miniTasks.filter((mini) => mini.enabled);
        const targetIndex = enabled.findIndex((mini) => mini.id === segmentId);
        if (targetIndex === -1) return false;
        const target = enabled[targetIndex];
        if (!target || target.locked) return false;
        const targetDuration = Math.max(1, Math.round(target.duration || 1));
        if (direction > 0) {
          const donor = findNearestDonor(enabled, targetIndex);
          if (donor) {
            const donorDuration = Math.max(1, Math.round(donor.duration || 1));
            if (donorDuration <= 1) return false;
            donor.duration = donorDuration - 1;
            target.duration = targetDuration + 1;
            return true;
          }
          target.duration = targetDuration + 1;
          state.undefinedDuration = sanitiseUndefinedDuration(state.undefinedDuration + 1);
          return true;
        }
        if (direction < 0) {
          if (targetDuration <= 1) return false;
          target.duration = targetDuration - 1;
          const recipient = findNearestRecipient(enabled, targetIndex);
          if (recipient) {
            recipient.duration = Math.max(1, Math.round(recipient.duration || 1)) + 1;
            return true;
          }
          if (state.undefinedDuration > 0) {
            state.undefinedDuration = sanitiseUndefinedDuration(state.undefinedDuration - 1);
            return true;
          }
          // Total duration shrinks naturally when no recipient is available.
          return true;
        }
        return false;
      }

      function beginMiniSegmentResize(event, task, segmentId, barElement, edge = 'right', neighborId = null) {
        if (!task || !segmentId) return;
        const handleEdge = edge === 'left' ? 'left' : 'right';
        const segmentOrder = task.miniTasks.filter((mini) => mini.enabled);
        const targetIndex = segmentOrder.findIndex((mini) => mini.id === segmentId);
        if (targetIndex === -1) return;
        const segment = segmentOrder[targetIndex];
        if (!segment || segment.locked) return;
        let activeSegmentId = segmentId;
        if (handleEdge === 'left') {
          const previous = neighborId
            ? segmentOrder.find((mini) => mini.id === neighborId)
            : segmentOrder[targetIndex - 1];
          if (!previous || previous.locked) return;
          activeSegmentId = previous.id;
        }
        event.preventDefault();
        event.stopPropagation();
        const handle = event.currentTarget;
        if (!handle || typeof handle.setPointerCapture !== 'function') return;
        const pointerId = event.pointerId;
        handle.setPointerCapture(pointerId);
        const state = {
          miniTasks: task.miniTasks.map((mini) => ({ ...mini })),
          undefinedDuration: sanitiseUndefinedDuration(task.undefinedDuration || 0)
        };
        computeMiniDurationSum(state.miniTasks);
        const dayWidth = getDayWidth();
        const initialPointerX = event.clientX;
        const initialStartDate = parseDate(task.startDate);
        if (!initialStartDate) {
          handle.releasePointerCapture(pointerId);
          return;
        }
        const initialStartIndex = Number(barElement.dataset.startIndex);
        let appliedDelta = 0;

        const applyPreview = () => {
          const totalDuration = Math.max(1, computeMiniDurationSum(state.miniTasks) + sanitiseUndefinedDuration(state.undefinedDuration));
          const previewEndDate = shiftWeekdays(initialStartDate, totalDuration - 1);
          const previewTask = {
            id: task.id,
            miniTasks: state.miniTasks.map((mini) => ({ ...mini })),
            undefinedDuration: sanitiseUndefinedDuration(state.undefinedDuration),
            startDate: formatDate(initialStartDate),
            endDate: formatDate(previewEndDate)
          };
          const previewSegments = buildMiniSegments(previewTask);
          updateMiniLayerElements(barElement, previewSegments, { interactive: false });
          const previewEndIndex = timelineDayIndexMap.get(formatDate(previewEndDate));
          if (typeof previewEndIndex === 'number') {
            barElement.dataset.endIndex = String(previewEndIndex);
            const width = Math.max(dayWidth, (previewEndIndex - initialStartIndex + 1) * dayWidth);
            barElement.style.width = `${width}px`;
          } else {
            const fallbackWidth = Math.max(dayWidth, totalDuration * dayWidth);
            barElement.style.width = `${fallbackWidth}px`;
          }
        };

        const applyDelta = (desiredDelta) => {
          let diff = desiredDelta - appliedDelta;
          if (!diff) return;
          while (diff !== 0) {
            const step = diff > 0 ? 1 : -1;
            const success = adjustMiniDurationStep(state, activeSegmentId, step);
            if (!success) break;
            appliedDelta += step;
            diff -= step;
          }
          applyPreview();
        };

        const onPointerMove = (moveEvent) => {
          const deltaPx = moveEvent.clientX - initialPointerX;
          const desiredDelta = Math.round(deltaPx / dayWidth);
          applyDelta(desiredDelta);
        };

        const cleanupPointer = () => {
          handle.removeEventListener('pointermove', onPointerMove);
          handle.removeEventListener('pointerup', onPointerUp);
          handle.removeEventListener('pointercancel', onPointerUp);
          if (handle.hasPointerCapture(pointerId)) {
            handle.releasePointerCapture(pointerId);
          }
        };

        const onPointerUp = () => {
          cleanupPointer();
          if (appliedDelta === 0) {
            selectedTaskId = task.id;
            renderAll();
            return;
          }
          computeMiniDurationSum(state.miniTasks);
          task.miniTasks.forEach((mini, index) => {
            if (!state.miniTasks[index]) return;
            mini.duration = state.miniTasks[index].duration;
          });
          task.undefinedDuration = sanitiseUndefinedDuration(state.undefinedDuration);
          const finalTotalDuration = Math.max(1, computeMiniDurationSum(task.miniTasks) + task.undefinedDuration);
          const finalEndDate = shiftWeekdays(initialStartDate, finalTotalDuration - 1);
          task.startDate = formatDate(initialStartDate);
          task.endDate = formatDate(finalEndDate);
          selectedTaskId = task.id;
          renderAll();
        };

        handle.addEventListener('pointermove', onPointerMove);
        handle.addEventListener('pointerup', onPointerUp);
        handle.addEventListener('pointercancel', onPointerUp);
        applyPreview();
      }

      function setBarLabel(barElement, task, startDate, endDate) {
        const label = barElement.querySelector('.task-label');
        const datesEl = barElement.querySelector('.task-dates') || document.createElement('span');
        const duration = Math.max(1, diffInWeekdays(startDate, endDate));
        barElement.title = `${task.name}
${formatDisplayDate(startDate)} → ${formatDisplayDate(endDate)} (${duration} days)`;
        datesEl.className = 'task-dates';
        datesEl.textContent = `${formatDisplayDate(startDate)} → ${formatDisplayDate(endDate)}`;
        if (!datesEl.isConnected) {
          const handle = barElement.querySelector('.handle');
          if (handle) {
            barElement.insertBefore(datesEl, handle);
          } else {
            barElement.appendChild(datesEl);
          }
        }
        if (label) label.textContent = task.name;
      }

      function attachResizeHandles(barElement, task) {
        barElement.querySelectorAll('.handle').forEach((handle) => {
          const type = handle.classList.contains('handle-start') ? 'start' : 'end';
          handle.addEventListener('pointerdown', (event) => {
            event.stopPropagation();
            event.preventDefault();
            handle.setPointerCapture(event.pointerId);
            const initialStart = parseDate(task.startDate);
            const initialEnd = parseDate(task.endDate);
            let previewStart = new Date(initialStart.getTime());
            let previewEnd = new Date(initialEnd.getTime());
            const progressEl = barElement.querySelector('.progress');

            const onPointerMove = (moveEvent) => {
              const calendarEl = plannerViewportEl || document.scrollingElement || document.documentElement;
              const headerRect = timelineHeaderEl.getBoundingClientRect();
              const relativeX = moveEvent.clientX - headerRect.left + calendarEl.scrollLeft;
              const dayWidth = getDayWidth();
              let dayIndex = Math.round(relativeX / dayWidth);
              dayIndex = Math.max(0, Math.min(dayIndex, timelineDays.length - 1));
              const targetDate = timelineDays[dayIndex];
              if (!targetDate) return;

              if (type === 'start') {
                let candidate = ensureWeekday(targetDate, 1);
                if (compareDates(candidate, previewEnd) > 0) {
                  candidate = shiftWeekdays(previewEnd, -(minimumTaskDuration(task) - 1));
                }
                previewStart = candidate;
              } else {
                let candidate = ensureWeekday(targetDate, -1);
                if (compareDates(candidate, previewStart) < 0) {
                  candidate = shiftWeekdays(previewStart, minimumTaskDuration(task) - 1);
                }
                previewEnd = candidate;
              }

              const duration = Math.max(minimumTaskDuration(task), diffInWeekdays(previewStart, previewEnd));
              const dayWidthForRender = getDayWidth();
              const previewStartIndex = timelineDayIndexMap.get(formatDate(previewStart));
              const previewEndIndex = timelineDayIndexMap.get(formatDate(previewEnd));
              if (typeof previewStartIndex !== 'number' || typeof previewEndIndex !== 'number') return;
              barElement.style.left = `${previewStartIndex * dayWidthForRender}px`;
              barElement.style.width = `${Math.max(dayWidthForRender, (previewEndIndex - previewStartIndex + 1) * dayWidthForRender)}px`;
              barElement.dataset.startIndex = String(previewStartIndex);
              barElement.dataset.endIndex = String(previewEndIndex);
              const previewSegments = buildMiniSegmentsPreview(task, duration);
              updateMiniLayerElements(barElement, previewSegments, { interactive: false });
              refreshStanddownLayer(barElement);
              if (progressEl) {
                const progressValue = Math.min(100, Math.max(0, task.progress));
                progressEl.style.width = `${progressValue}%`;
                progressEl.classList.toggle('is-full', progressValue >= 99.5);
              }
              setBarLabel(barElement, task, previewStart, previewEnd);
            };

            const onPointerUp = () => {
              handle.removeEventListener('pointermove', onPointerMove);
              handle.removeEventListener('pointerup', onPointerUp);
              handle.removeEventListener('pointercancel', onPointerUp);
              handle.releasePointerCapture(event.pointerId);
              if (type === 'start') {
                applyNewStartDate(task, previewStart, initialEnd);
              } else {
                applyNewEndDate(task, initialStart, previewEnd);
              }
              renderAll();
              selectTask(task.id);
            };

            handle.addEventListener('pointermove', onPointerMove);
            handle.addEventListener('pointerup', onPointerUp);
            handle.addEventListener('pointercancel', onPointerUp);
          });
        });
      }

      function enableBarDrag(barElement, task) {
        barElement.addEventListener('pointerdown', (event) => {
          if (event.button && event.button !== 0) return;
          if (event.target.closest('.handle') || event.target.closest('.mini-handle')) return;
          if (event.target.closest('button, input, select, textarea, label')) return;
          event.stopPropagation();
          const initialStart = parseDate(task.startDate);
          const initialEnd = parseDate(task.endDate);
          if (!initialStart || !initialEnd) return;
          const calendarEl = plannerViewportEl || document.scrollingElement || document.documentElement;
          if (!calendarEl) return;
          const initialPointer = event.clientX + calendarEl.scrollLeft;
          const initialLeft = barElement.style.left;
          let latestShift = 0;
          let dragActive = false;

          const activateDrag = () => {
            if (dragActive) return;
            dragActive = true;
            barElement.setPointerCapture(event.pointerId);
          };

          const cleanup = () => {
            barElement.removeEventListener('pointermove', onPointerMove);
            barElement.removeEventListener('pointerup', onPointerUp);
            barElement.removeEventListener('pointercancel', onPointerUp);
            if (dragActive && barElement.hasPointerCapture(event.pointerId)) {
              barElement.releasePointerCapture(event.pointerId);
            }
          };

          const onPointerMove = (moveEvent) => {
            const currentPointer = moveEvent.clientX + calendarEl.scrollLeft;
            const deltaPx = currentPointer - initialPointer;
            const dayWidth = getDayWidth();
            if (!dragActive && Math.abs(deltaPx) >= Math.max(6, dayWidth * 0.35)) {
              activateDrag();
            }
            if (!dragActive) return;
            moveEvent.preventDefault();
            const shift = Math.round(deltaPx / dayWidth);
            if (shift === latestShift) return;
            latestShift = shift;
            const previewStart = shiftWeekdays(initialStart, shift);
            const previewEnd = shiftWeekdays(initialEnd, shift);
            const previewStartIndex = timelineDayIndexMap.get(formatDate(previewStart));
            const previewEndIndex = timelineDayIndexMap.get(formatDate(previewEnd));
            if (typeof previewStartIndex !== 'number' || typeof previewEndIndex !== 'number') return;
            barElement.style.left = `${previewStartIndex * dayWidth}px`;
            barElement.dataset.startIndex = String(previewStartIndex);
            barElement.dataset.endIndex = String(previewEndIndex);
            refreshStanddownLayer(barElement);
            setBarLabel(barElement, task, previewStart, previewEnd);
          };

          const onPointerUp = () => {
            if (dragActive) {
              if (latestShift !== 0) {
                const newStart = shiftWeekdays(initialStart, latestShift);
                const newEnd = shiftWeekdays(initialEnd, latestShift);
                task.startDate = formatDate(newStart);
                task.endDate = formatDate(newEnd);
                renderAll();
                selectTask(task.id);
              } else {
                barElement.style.left = initialLeft;
                const originalStartIndex = timelineDayIndexMap.get(task.startDate);
                const originalEndIndex = timelineDayIndexMap.get(task.endDate);
                if (typeof originalStartIndex === 'number') {
                  barElement.dataset.startIndex = String(originalStartIndex);
                } else {
                  delete barElement.dataset.startIndex;
                }
                if (typeof originalEndIndex === 'number') {
                  barElement.dataset.endIndex = String(originalEndIndex);
                } else {
                  delete barElement.dataset.endIndex;
                }
                refreshStanddownLayer(barElement);
                setBarLabel(barElement, task, initialStart, initialEnd);
              }
            }
            cleanup();
          };

          barElement.addEventListener('pointermove', onPointerMove);
          barElement.addEventListener('pointerup', onPointerUp);
          barElement.addEventListener('pointercancel', onPointerUp);
        });
      }

      function renderGantt() {
        const previousScrollTop = ganttBodyScrollEl ? ganttBodyScrollEl.scrollTop : 0;
        ganttBodyEl.innerHTML = '';
        timelineHeaderEl.innerHTML = '';
        const { start, end } = computeTimelineRange();
        timelineRangeStart = start;
        timelineRangeEnd = end;
        timelineDays = buildTimelineDays(start, end);
        const todayUtc = getTodayUtc();
        const todayIndex = todayUtc ? timelineDays.findIndex((day) => isSameUtcDay(day, todayUtc)) : -1;
        timelineDayIndexMap = new Map();
        timelineDays.forEach((day, index) => {
          timelineDayIndexMap.set(formatDate(day), index);
        });
        const getTimelineIndex = (value) => {
          if (typeof value === 'number' && Number.isFinite(value)) return value;
          const key = typeof value === 'string' ? value : formatDate(value instanceof Date ? value : parseDate(value));
          if (typeof key === 'string' && timelineDayIndexMap.has(key)) {
            const stored = timelineDayIndexMap.get(key);
            if (typeof stored === 'number') return stored;
          }
          const date = typeof value === 'string' ? parseDate(value) : (value instanceof Date ? value : null);
          if (!(date instanceof Date)) return -1;
          for (let i = 0; i < timelineDays.length; i += 1) {
            if (compareDates(timelineDays[i], date) === 0) return i;
          }
          return -1;
        };
        const dayHighlightMap = timelineDays.map(() => new Set());
        const highlightSegments = [];
        if (todayIndex !== -1) {
          highlightSegments.push({
            id: 'today',
            type: 'today',
            startIndex: todayIndex,
            endIndex: todayIndex
          });
        }
        const milestoneSegments = buildMilestoneSegments(timelineDays);
        milestoneSegments.forEach((segment) => {
          highlightSegments.push(segment);
        });
        const normalizedSegments = highlightSegments
          .map((segment) => {
            const startIndex = Math.max(0, Math.min(timelineDays.length - 1, segment.startIndex));
            const endIndex = Math.max(startIndex, Math.min(timelineDays.length - 1, segment.endIndex));
            return { ...segment, startIndex, endIndex };
          })
          .filter((segment) => segment.startIndex <= segment.endIndex);
        currentStanddownSegments = normalizedSegments.filter((segment) => segment.type === 'standdown');
        normalizedSegments.forEach((segment) => {
          for (let index = segment.startIndex; index <= segment.endIndex; index += 1) {
            dayHighlightMap[index]?.add(segment.type);
          }
        });
        if (!timelineDays.length) {
          timelineHeaderEl.classList.remove('week-view');
          const emptyHeader = document.createElement('div');
          emptyHeader.className = 'empty-state';
          emptyHeader.textContent = 'No working days to display.';
          timelineHeaderEl.appendChild(emptyHeader);
          updateZoomControls();
          if (ganttBodyScrollEl) ganttBodyScrollEl.scrollTop = 0;
          return;
        }
        const dayWidth = getDayWidth();
        timelineHeaderEl.style.gridTemplateColumns = `repeat(${timelineDays.length}, ${dayWidth}px)`;
        const yearGroups = groupTimelineDaysByYear(timelineDays);
        const monthGroups = groupTimelineDaysByMonth(timelineDays);
        if (timelineViewMode === 'weeks') {
          timelineHeaderEl.classList.add('week-view');
          timelineHeaderEl.style.gridTemplateRows = 'auto auto auto';
        } else {
          timelineHeaderEl.classList.remove('week-view');
          timelineHeaderEl.style.gridTemplateRows = 'auto auto auto auto';
        }
        adjustGanttOffset();

        normalizedSegments.forEach((segment) => {
          const highlightEl = document.createElement('div');
          highlightEl.className = `timeline-highlight timeline-highlight--${segment.type}`;
          highlightEl.style.gridColumn = `${segment.startIndex + 1} / ${segment.endIndex + 2}`;
          highlightEl.style.gridRow = '1 / -1';
          if (segment.type === 'today') {
            highlightEl.title = 'Today';
          } else if (segment.name) {
            const label = segment.type === 'deadline' ? 'Deadline' : 'Stand-down';
            highlightEl.title = `${segment.name} • ${label}`;
          }
          timelineHeaderEl.appendChild(highlightEl);
        });

        yearGroups.forEach((group) => {
          const cell = document.createElement('div');
          cell.className = 'timeline-year';
          cell.textContent = String(group.year);
          cell.style.gridColumn = `${group.startIndex + 1} / span ${group.length}`;
          cell.style.gridRow = '1';
          timelineHeaderEl.appendChild(cell);
        });

        monthGroups.forEach((group) => {
          const cell = document.createElement('div');
          cell.className = 'timeline-month';
          const label = timelineViewMode === 'weeks'
            ? MONTH_NAMES[group.month].slice(0, 3)
            : MONTH_NAMES[group.month];
          cell.textContent = label;
          cell.style.gridColumn = `${group.startIndex + 1} / span ${group.length}`;
          cell.style.gridRow = '2';
          timelineHeaderEl.appendChild(cell);
        });

        if (timelineViewMode === 'weeks') {
          const weekGroups = groupTimelineDaysByWeek(timelineDays);
          weekGroups.forEach((group) => {
            const cell = document.createElement('div');
            cell.className = 'timeline-week';
            cell.style.gridColumn = `${group.startIndex + 1} / span ${Math.max(1, group.length)}`;
            const monday = new Date(group.start.getTime());
            const dayOfWeek = monday.getUTCDay();
            const diff = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
            monday.setUTCDate(monday.getUTCDate() - diff);
            const mondayShort = formatShortDate(monday);
            cell.textContent = mondayShort.split('/')[0];
            cell.title = `${formatDisplayDate(group.start)} → ${formatDisplayDate(group.end)} (${group.length} working day${group.length !== 1 ? 's' : ''})`;
            cell.style.gridRow = '3';
            const highlightSet = new Set();
            const span = Math.max(1, group.length);
            for (let offsetIndex = 0; offsetIndex < span; offsetIndex += 1) {
              const dayIndex = group.startIndex + offsetIndex;
              dayHighlightMap[dayIndex]?.forEach((type) => highlightSet.add(type));
            }
            if (highlightSet.has('today')) cell.classList.add('today');
            if (highlightSet.has('deadline')) cell.classList.add('milestone-deadline');
            if (highlightSet.has('standdown')) cell.classList.add('milestone-standdown');
            timelineHeaderEl.appendChild(cell);
          });
        } else {
          timelineDays.forEach((day, index) => {
            const dayName = document.createElement('div');
            dayName.className = 'timeline-day-name';
            dayName.textContent = DAY_NAMES[day.getUTCDay()];
            dayName.style.gridRow = '3';
            dayName.style.gridColumn = `${index + 1}`;
            const highlightSet = dayHighlightMap[index] || new Set();
            if (highlightSet.has('today')) dayName.classList.add('today');
            if (highlightSet.has('deadline')) dayName.classList.add('milestone-deadline');
            if (highlightSet.has('standdown')) dayName.classList.add('milestone-standdown');
            timelineHeaderEl.appendChild(dayName);

            const dayNumber = document.createElement('div');
            dayNumber.className = 'timeline-day-number';
            dayNumber.textContent = formatShortDate(day).split('/')[0];
            dayNumber.style.gridRow = '4';
            dayNumber.style.gridColumn = `${index + 1}`;
            if (highlightSet.has('today')) dayNumber.classList.add('today');
            if (highlightSet.has('deadline')) dayNumber.classList.add('milestone-deadline');
            if (highlightSet.has('standdown')) dayNumber.classList.add('milestone-standdown');
            timelineHeaderEl.appendChild(dayNumber);
          });
        }

        if (!tasks.length) {
          const empty = document.createElement('div');
          empty.className = 'empty-state';
          empty.textContent = 'Create a task to visualise the schedule.';
          ganttBodyEl.appendChild(empty);
          updateZoomControls();
          if (ganttBodyScrollEl) ganttBodyScrollEl.scrollTop = 0;
          return;
        }

        const orderedEntries = getOrderedTasks();
        orderedEntries.forEach(({ task, depth }) => {
          const isStage = task.entryType === 'stage';
          const isStageChild = depth > 0 && !isStage;
          const row = document.createElement('div');
          row.className = 'gantt-row';
          row.style.width = `${timelineDays.length * dayWidth}px`;
          row.dataset.taskId = task.id;
          if (isStage) row.classList.add('stage-row');
          if (isStageChild) row.classList.add('stage-child');

          const grid = document.createElement('div');
          grid.className = 'gantt-grid';
          grid.style.gridTemplateColumns = `repeat(${timelineDays.length}, ${dayWidth}px)`;
          timelineDays.forEach((_, index) => {
            const cell = document.createElement('div');
            cell.className = 'day-cell';
            if (index % 5 === 0) cell.classList.add('week-start');
            const highlightSet = dayHighlightMap[index] || new Set();
            if (highlightSet.has('today')) cell.classList.add('today');
            if (highlightSet.has('deadline')) cell.classList.add('milestone-deadline');
            if (highlightSet.has('standdown')) cell.classList.add('milestone-standdown');
            grid.appendChild(cell);
          });

          row.appendChild(grid);

          const startDate = parseDate(task.startDate);
          const startIndex = getTimelineIndex(task.startDate);
          if (isStage && (!startDate || typeof startIndex !== 'number')) {
            row.addEventListener('click', () => selectTask(task.id));
            ganttBodyEl.appendChild(row);
            return;
          }
          if (!isStage && (!startDate || typeof startIndex !== 'number')) {
            return;
          }
          const isSingleEvent = Boolean(task.singleEvent);
          if (isSingleEvent) {
            const marker = document.createElement('div');
            marker.className = 'single-event-marker';
            if (task.id === selectedTaskId) marker.classList.add('selected');
            const markerLeft = (startIndex * dayWidth) + (dayWidth / 2);
            marker.style.left = `${markerLeft}px`;
            marker.dataset.startIndex = String(startIndex);
            marker.dataset.endIndex = String(startIndex);
            marker.title = `${task.name}
${formatDisplayDate(startDate)} (Single event)`;
            marker.addEventListener('click', (event) => {
              event.stopPropagation();
              selectTask(task.id);
            });
            row.appendChild(marker);
            ganttBodyEl.appendChild(row);
            return;
          }
          const endDate = parseDate(task.endDate);
          const endIndex = getTimelineIndex(task.endDate);
          if (typeof endIndex !== 'number' || startIndex > endIndex) {
            return;
          }
          const barLeft = startIndex * dayWidth;
          const barWidth = Math.max(dayWidth, (endIndex - startIndex + 1) * dayWidth);
          const bar = document.createElement('div');
          bar.className = 'task-bar';
          if (isStage) bar.classList.add('stage-bar');
          if (task.id === selectedTaskId) bar.classList.add('selected');
          bar.style.left = `${barLeft}px`;
          bar.style.width = `${barWidth}px`;
          bar.dataset.startIndex = String(startIndex);
          bar.dataset.endIndex = String(endIndex);

          const label = document.createElement('span');
          label.className = 'task-label';
          label.textContent = task.name;

          const progress = document.createElement('div');
          progress.className = 'progress';
          const progressValue = Math.min(100, Math.max(0, task.progress));
          progress.style.width = `${progressValue}%`;
          progress.classList.toggle('is-full', progressValue >= 99.5);

          let miniLayer = null;
          let standdownLayer = null;
          if (!isStage) {
            miniLayer = document.createElement('div');
            miniLayer.className = 'mini-layer';
            const segments = buildMiniSegments(task);
            segments.forEach(() => {
              miniLayer.appendChild(createMiniSegmentElement());
            });
            standdownLayer = document.createElement('div');
            standdownLayer.className = 'standdown-layer';
            bar.appendChild(miniLayer);
            bar.appendChild(progress);
            bar.appendChild(standdownLayer);
            refreshStanddownLayer(bar);
            bar.appendChild(label);
            const handleStart = document.createElement('div');
            handleStart.className = 'handle handle-start';
            const handleEnd = document.createElement('div');
            handleEnd.className = 'handle handle-end';
            bar.appendChild(handleStart);
            bar.appendChild(handleEnd);
            setBarLabel(bar, task, startDate, endDate);
            updateMiniLayerElements(bar, segments, { task });
            attachResizeHandles(bar, task);
            enableBarDrag(bar, task);
          } else {
            standdownLayer = document.createElement('div');
            standdownLayer.className = 'standdown-layer';
            bar.appendChild(progress);
            bar.appendChild(standdownLayer);
            refreshStanddownLayer(bar);
            bar.appendChild(label);
            setBarLabel(bar, task, startDate, endDate);
          }

          bar.addEventListener('click', (event) => {
            event.stopPropagation();
            selectTask(task.id);
          });

          row.appendChild(bar);
          row.addEventListener('click', () => selectTask(task.id));
          ganttBodyEl.appendChild(row);
        });
        adjustGanttOffset();
        updateZoomControls();
        if (ganttBodyScrollEl) ganttBodyScrollEl.scrollTop = previousScrollTop;
        scheduleTimelineHorizontalSync();
      }

      async function handleSavePdf() {
        const jsPdfCtor = await ensureJsPdfLoaded();
        if (typeof jsPdfCtor !== 'function') {
          console.error('jsPDF library failed to load.');
          window.alert('Unable to save the PDF because the export component failed to load.');
          return;
        }
        if (!tasks.length) {
          window.alert('Add at least one task before saving the PDF.');
          return;
        }
        if (!timelineDays.length) {
          renderGantt();
        }
        if (!timelineDays.length) {
          window.alert('Generate the schedule before exporting it as a PDF.');
          return;
        }

        updateAllStageSummaries();

        const doc = new jsPdfCtor({ orientation: 'landscape', unit: 'mm', format: 'a3' });
        const margin = 8;
        const pageWidth = doc.internal.pageSize.getWidth();
        const pageHeight = doc.internal.pageSize.getHeight();
        const contentWidth = pageWidth - (margin * 2);
        const contentHeight = pageHeight - (margin * 2);
        const leftColumnWidth = 95;
        const rightColumnWidth = contentWidth - leftColumnWidth;
        const columnLabels = ['ID', 'Task', 'Start', 'End', 'Duration', 'Progress'];
        const columnWeights = [45, 115, 85, 85, 60, 70];
        const totalWeight = columnWeights.reduce((sum, weight) => sum + weight, 0);
        const columnWidths = columnWeights.map((weight) => (weight / totalWeight) * leftColumnWidth);
        const orderedEntries = getOrderedTasks();
        const identifierMap = buildTaskIdentifiers(orderedEntries);
        const tasksSnapshot = orderedEntries.map(({ task, depth }) => ({
          ...task,
          depth: depth || 0,
          identifier: identifierMap.get(task.id) || '—',
          miniTasks: Array.isArray(task.miniTasks) ? task.miniTasks.map((mini) => ({ ...mini })) : []
        }));
        const dayCount = timelineDays.length;
        const dayWidth = dayCount ? rightColumnWidth / dayCount : rightColumnWidth;
        const timelineRowHeight = 6;
        const timelineRowCount = 2;
        const timelineHeaderHeight = timelineRowHeight * timelineRowCount;
        const textPadding = 1.5;
        const timelineStartX = margin + leftColumnWidth;
        const pageBottom = margin + contentHeight;
        const defaultTextColor = { r: 31, g: 41, b: 55 };
        const defaultDrawColor = { r: 214, g: 219, b: 231 };
        const headerFill = { r: 234, g: 238, b: 248 };
        const zebraFill = { r: 246, g: 248, b: 252 };
        const stageFill = { r: 250, g: 250, b: 210 };
        const legendItems = Object.entries(TASK_COLOR_MAP);
        const supportsOpacity = typeof doc.GState === 'function';
        const progressOverlayState = supportsOpacity ? doc.GState({ opacity: 0.35 }) : null;
        const resetOpacityState = supportsOpacity ? doc.GState({ opacity: 1 }) : null;
        const todayUtcPdf = getTodayUtc();
        const todayIndexPdf = todayUtcPdf ? timelineDays.findIndex((day) => compareDates(day, todayUtcPdf) === 0) : -1;
        const todayMarker = todayIndexPdf !== -1 ? {
          index: todayIndexPdf,
          x: timelineStartX + (todayIndexPdf * dayWidth)
        } : null;
        const pdfTimelineIndexMap = new Map();
        timelineDays.forEach((day, index) => {
          pdfTimelineIndexMap.set(formatDate(day), index);
        });
        const getPdfDayIndex = (date) => {
          if (!(date instanceof Date)) return -1;
          const key = formatDate(date);
          if (pdfTimelineIndexMap.has(key)) return pdfTimelineIndexMap.get(key);
          for (let i = 0; i < timelineDays.length; i += 1) {
            if (compareDates(timelineDays[i], date) === 0) return i;
          }
          return -1;
        };
        const highlightPriority = { standdown: 0, deadline: 1, today: 2 };
        const highlightPalette = {
          today: { fill: { r: 255, g: 228, b: 232 }, border: { r: 220, g: 38, b: 38 } },
          deadline: { fill: { r: 255, g: 243, b: 207 }, border: { r: 217, g: 119, b: 6 } },
          standdown: { fill: { r: 229, g: 231, b: 235 }, border: { r: 71, g: 85, b: 105 } }
        };
        const timelineDateFontSize = 4;
        const logoImage = await loadPdfLogo();
        const highlightSegmentsPdf = [];
        if (todayMarker) {
          highlightSegmentsPdf.push({
            type: 'today',
            startIndex: todayMarker.index,
            endIndex: todayMarker.index
          });
        }
        const milestoneSegmentsPdf = buildMilestoneSegments(timelineDays);
        milestoneSegmentsPdf.forEach((segment) => {
          highlightSegmentsPdf.push(segment);
        });
        const normalizedHighlightSegments = highlightSegmentsPdf
          .map((segment) => {
            const startIndex = Math.max(0, Math.min(dayCount - 1, segment.startIndex));
            const endIndex = Math.max(startIndex, Math.min(dayCount - 1, segment.endIndex));
            return { ...segment, startIndex, endIndex };
          })
          .filter((segment) => segment.startIndex <= segment.endIndex);
        const segmentsForDrawing = normalizedHighlightSegments
          .slice()
          .sort((a, b) => {
            const priorityDifference = (highlightPriority[a.type] ?? 0) - (highlightPriority[b.type] ?? 0);
            if (priorityDifference !== 0) return priorityDifference;
            return a.startIndex - b.startIndex;
          });
        const pdfDayHighlights = timelineDays.map(() => new Set());
        normalizedHighlightSegments.forEach((segment) => {
          for (let index = segment.startIndex; index <= segment.endIndex; index += 1) {
            pdfDayHighlights[index]?.add(segment.type);
          }
        });
        const boundaryTypes = {};
        const applyBoundaryType = (index, type) => {
          if (index < 0 || index > dayCount) return;
          const existing = boundaryTypes[index];
          if (!existing || (highlightPriority[type] ?? 0) >= (highlightPriority[existing] ?? 0)) {
            boundaryTypes[index] = type;
          }
        };
        segmentsForDrawing.forEach((segment) => {
          applyBoundaryType(segment.startIndex, segment.type);
          applyBoundaryType(segment.endIndex + 1, segment.type);
        });

        doc.setFont('helvetica', 'normal');
        doc.setFontSize(9);
        doc.setLineHeightFactor(1.2);
        doc.setTextColor(defaultTextColor.r, defaultTextColor.g, defaultTextColor.b);
        doc.setLineWidth(0.2);

        const truncateText = (value, maxWidth) => {
          if (!value) return '';
          let text = String(value);
          if (doc.getTextWidth(text) <= maxWidth) return text;
          const ellipsis = '...';
          while (text.length > 0 && doc.getTextWidth(`${text}${ellipsis}`) > maxWidth) {
            text = text.slice(0, -1);
          }
          return text.length ? `${text}${ellipsis}` : ellipsis;
        };

        const lineHeight = (doc.getFontSize() * doc.getLineHeightFactor()) / doc.internal.scaleFactor;
        const minRowHeight = 12;
        const verticalPadding = 2;
        const nameColumnWidth = Math.max(10, columnWidths[1] - (textPadding * 2));

        const formatDateCell = (value) => {
          const date = parseDate(value);
          if (!(date instanceof Date) || Number.isNaN(date.getTime())) {
            return ['--/--', '----'];
          }
          const day = String(date.getUTCDate()).padStart(2, '0');
          const month = String(date.getUTCMonth() + 1).padStart(2, '0');
          const year = String(date.getUTCFullYear());
          return [`${day}/${month}`, year];
        };

        const buildNameLines = (rowTask) => {
          const depth = Math.max(0, rowTask?.depth || 0);
          const indent = depth ? ''.padStart(depth * 2, ' ') : '';
          const baseName = (rowTask?.name || '').trim() || (rowTask?.entryType === 'stage' ? 'Stage' : 'Untitled task');
          const label = `${indent}${baseName}`;
          let lines = doc.splitTextToSize(label, nameColumnWidth);
          if (!Array.isArray(lines) || !lines.length) lines = ['Untitled task'];
          const maxLines = 3;
          if (lines.length > maxLines) {
            const limited = lines.slice(0, maxLines);
            const ellipsis = '...';
            let last = limited[maxLines - 1].trimEnd();
            while (last.length && doc.getTextWidth(`${last}${ellipsis}`) > nameColumnWidth) {
              last = last.slice(0, -1).trimEnd();
            }
            limited[maxLines - 1] = last ? `${last}${ellipsis}` : ellipsis;
            return limited;
          }
          return lines;
        };

        const computeRowLayout = (task) => {
          const duration = getTaskDuration(task);
          const progressValue = Math.min(100, Math.max(0, Number.isFinite(task.progress) ? task.progress : 0));
          const columnLines = [
            [task.identifier || task.id || '—'],
            buildNameLines(task),
            formatDateCell(task.startDate),
            formatDateCell(task.endDate),
            [String(duration), 'Days'],
            [`${Math.round(progressValue)}%`]
          ].map((cellLines) => cellLines.map((line) => (line === undefined || line === null ? '' : String(line))));
          const lineCounts = columnLines.map((lines) => Math.max(1, lines.length));
          const maxLineCount = Math.max(...lineCounts);
          const rowHeight = Math.max(minRowHeight, (maxLineCount * lineHeight) + (verticalPadding * 2));
          return { rowHeight, columnLines, lineCounts, duration, progressValue };
        };

        const applyHighlightTextStyle = (types) => {
          if (types.has('today')) {
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(220, 38, 38);
            return true;
          }
          if (types.has('deadline')) {
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(180, 83, 9);
            return true;
          }
          if (types.has('standdown')) {
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(51, 65, 85);
            return true;
          }
          return false;
        };

        const resetHighlightTextStyle = () => {
          doc.setFont('helvetica', 'normal');
          doc.setFontSize(timelineDateFontSize);
          doc.setTextColor(defaultTextColor.r, defaultTextColor.g, defaultTextColor.b);
        };

        const drawLegend = (topY, startX = margin) => {
          doc.setFont('helvetica', 'normal');
          doc.setFontSize(9);
          doc.setTextColor(defaultTextColor.r, defaultTextColor.g, defaultTextColor.b);
          if (!legendItems.length) {
            doc.text('Legend: not configured', margin, topY + 4);
            return topY + 8;
          }
          const swatchSize = 4;
          const lineHeight = swatchSize + 2.5;
          let x = startX;
          let y = topY;
          const maxX = margin + contentWidth;
          legendItems.forEach(([label, color]) => {
            const textWidth = doc.getTextWidth(label);
            const requiredWidth = swatchSize + 2 + textWidth + 6;
            if (x + requiredWidth > maxX) {
              x = startX;
              y += lineHeight;
            }
            const rgb = parseColorToRgb(color);
            doc.setFillColor(rgb.r, rgb.g, rgb.b);
            doc.rect(x, y, swatchSize, swatchSize, 'F');
            doc.setDrawColor(160, 167, 187);
            doc.rect(x, y, swatchSize, swatchSize);
            doc.setTextColor(defaultTextColor.r, defaultTextColor.g, defaultTextColor.b);
            doc.text(label, x + swatchSize + 2, y + swatchSize - 0.6);
            x += requiredWidth;
          });
          doc.setDrawColor(defaultDrawColor.r, defaultDrawColor.g, defaultDrawColor.b);
          return y + lineHeight;
        };

        const drawDocumentHeader = (topY) => {
          let textStartX = margin;
          let legendStartY = topY;
          if (logoImage && logoImage.dataUrl) {
            const aspect = logoImage.width && logoImage.height ? logoImage.width / logoImage.height : 1;
            const logoHeight = 16;
            const logoWidth = logoHeight * (Number.isFinite(aspect) && aspect > 0 ? aspect : 1);
            try {
              doc.addImage(logoImage.dataUrl, 'PNG', margin, topY, logoWidth, logoHeight);
              textStartX = margin + logoWidth + 4;
              legendStartY = topY + logoHeight + 2;
            } catch (error) {
              console.warn('Unable to add logo to PDF header.', error);
            }
          }
          doc.setFont('helvetica', 'bold');
          doc.setFontSize(18);
          doc.setTextColor(defaultTextColor.r, defaultTextColor.g, defaultTextColor.b);
          const titleBaseline = topY + 7;
          doc.text('BB: Project Programme', textStartX, titleBaseline);
          const legendTop = Math.max(titleBaseline + 2.5, legendStartY);
          const legendBottom = drawLegend(legendTop, margin);
          return legendBottom + 2;
        };

        const drawTimelineGridLines = (topY, height) => {
          if (!dayCount) return;
          const originalLineWidth = doc.getLineWidth();
          for (let index = 0; index <= dayCount; index += 1) {
            const x = timelineStartX + (index * dayWidth);
            const boundaryType = boundaryTypes[index];
            const isWeekStart = index % 5 === 0;
            if (boundaryType) {
              const palette = highlightPalette[boundaryType];
              doc.setDrawColor(palette.border.r, palette.border.g, palette.border.b);
              doc.setLineWidth(boundaryType === 'today' ? 0.45 : 0.3);
            } else if (isWeekStart) {
              doc.setDrawColor(190, 195, 205);
              doc.setLineWidth(0.1);
            } else {
              doc.setDrawColor(defaultDrawColor.r, defaultDrawColor.g, defaultDrawColor.b);
              doc.setLineWidth(0.1);
            }
            doc.line(x, topY, x, topY + height);
          }
          doc.setDrawColor(defaultDrawColor.r, defaultDrawColor.g, defaultDrawColor.b);
          doc.setLineWidth(originalLineWidth);
        };

        const drawTimelineHeader = (topY) => {
          doc.setFillColor(244, 246, 252);
          doc.rect(timelineStartX, topY, rightColumnWidth, timelineHeaderHeight, 'F');
          doc.setDrawColor(defaultDrawColor.r, defaultDrawColor.g, defaultDrawColor.b);
          doc.rect(timelineStartX, topY, rightColumnWidth, timelineHeaderHeight);

          segmentsForDrawing.forEach((segment) => {
            const palette = highlightPalette[segment.type];
            if (!palette) return;
            const startX = timelineStartX + (segment.startIndex * dayWidth);
            const width = (segment.endIndex - segment.startIndex + 1) * dayWidth;
            doc.setFillColor(palette.fill.r, palette.fill.g, palette.fill.b);
            doc.rect(startX, topY, width, timelineHeaderHeight, 'F');
          });

          doc.setDrawColor(defaultDrawColor.r, defaultDrawColor.g, defaultDrawColor.b);
          doc.rect(timelineStartX, topY, rightColumnWidth, timelineHeaderHeight);

          const yearBaseline = topY + timelineRowHeight - 1;
          const dateBaseline = topY + timelineHeaderHeight - 2;

          doc.setFont('helvetica', 'bold');
          doc.setFontSize(8);
          const yearGroups = groupTimelineDaysByYear(timelineDays);
          yearGroups.forEach((group) => {
            const startX = timelineStartX + (group.startIndex * dayWidth);
            const centreX = startX + ((group.length * dayWidth) / 2);
            doc.text(String(group.year), centreX, yearBaseline, { align: 'center' });
          });

          doc.setFont('helvetica', 'normal');
          doc.setFontSize(timelineDateFontSize);
          if (timelineViewMode === 'weeks') {
            const weekGroups = groupTimelineDaysByWeek(timelineDays);
            weekGroups.forEach((group) => {
              const startX = timelineStartX + (group.startIndex * dayWidth);
              const centreX = startX + ((Math.max(1, group.length) * dayWidth) / 2);
              const highlightSet = new Set();
              const span = Math.max(1, group.length);
              for (let offset = 0; offset < span; offset += 1) {
                const dayIndex = group.startIndex + offset;
                pdfDayHighlights[dayIndex]?.forEach((type) => highlightSet.add(type));
              }
              const styled = applyHighlightTextStyle(highlightSet);
              const weekLabel = formatShortDate(group.start);
              doc.text(weekLabel, centreX, dateBaseline, { align: 'center', angle: 90 });
              if (styled) resetHighlightTextStyle();
            });
          } else {
            timelineDays.forEach((day, index) => {
              const centreX = timelineStartX + ((index + 0.5) * dayWidth);
              const highlightSet = pdfDayHighlights[index] || new Set();
              const styled = applyHighlightTextStyle(highlightSet);
              const dateLabel = formatShortDate(day);
              doc.text(dateLabel, centreX, dateBaseline, { align: 'center', angle: 90 });
              if (styled) resetHighlightTextStyle();
            });
          }

          drawTimelineGridLines(topY, timelineHeaderHeight);
        };

        const drawTaskRow = (task, topY, rowIndex, layout) => {
          const {
            rowHeight,
            columnLines,
            lineCounts,
            progressValue
          } = layout;
          const isStageRow = task.entryType === 'stage';
          if (isStageRow) {
            doc.setFillColor(stageFill.r, stageFill.g, stageFill.b);
            doc.rect(margin, topY, contentWidth, rowHeight, 'F');
          } else if (rowIndex % 2 === 0) {
            doc.setFillColor(zebraFill.r, zebraFill.g, zebraFill.b);
            doc.rect(margin, topY, contentWidth, rowHeight, 'F');
          }

          if (segmentsForDrawing.length && dayWidth > 0) {
            segmentsForDrawing.forEach((segment) => {
              const palette = highlightPalette[segment.type];
              if (!palette) return;
              const segmentX = timelineStartX + (segment.startIndex * dayWidth);
              const width = (segment.endIndex - segment.startIndex + 1) * dayWidth;
              doc.setFillColor(palette.fill.r, palette.fill.g, palette.fill.b);
              doc.rect(segmentX, topY, width, rowHeight, 'F');
            });
          }

          doc.setDrawColor(defaultDrawColor.r, defaultDrawColor.g, defaultDrawColor.b);
          doc.line(margin, topY, margin + contentWidth, topY);
          doc.line(margin, topY + rowHeight, margin + contentWidth, topY + rowHeight);

          doc.setFont('helvetica', 'normal');
          doc.setFontSize(9);
          let cellX = margin;
          const originalLineWidth = doc.getLineWidth();
          doc.setLineWidth(0.1);

          columnLines.forEach((lines, index) => {
            const width = columnWidths[index];
            const effectiveLines = Math.max(1, lineCounts[index]);
            const contentHeight = effectiveLines * lineHeight;
            const textTop = topY + Math.max(verticalPadding, (rowHeight - contentHeight) / 2);
            const cleanedLines = lines.length ? lines.map((line) => (line === '' ? ' ' : line)) : [' '];
            if (index === 0) {
              doc.text(cleanedLines, cellX + textPadding, textTop, { baseline: 'top' });
            } else if (index === 1) {
              doc.text(cleanedLines, cellX + textPadding, textTop, { baseline: 'top' });
            } else {
              const centreX = cellX + (width / 2);
              doc.text(cleanedLines, centreX, textTop, { baseline: 'top', align: 'center' });
            }
            cellX += width;
            if (index < columnLines.length - 1) {
              doc.line(cellX, topY, cellX, topY + rowHeight);
            }
          });

          doc.line(timelineStartX, topY, timelineStartX, topY + rowHeight);
          doc.setLineWidth(originalLineWidth);

          drawTimelineGridLines(topY, rowHeight);

          const startDate = parseDate(task.startDate);
          const endDate = parseDate(task.endDate);
          if (!startDate || !endDate || !dayCount) return;

          let startIndex = getPdfDayIndex(startDate);
          let endIndex = getPdfDayIndex(endDate);
          if (startIndex === -1 || endIndex === -1) return;
          const offset = timelineViewMode === 'days'
            ? -1
            : (timelineViewMode === 'weeks' ? 1 : 0);
          if (offset !== 0) {
            startIndex += offset;
            endIndex += offset;
          }
          startIndex = Math.max(0, Math.min(dayCount - 1, startIndex));
          endIndex = Math.max(startIndex, Math.min(dayCount - 1, endIndex));
          if (typeof startIndex !== 'number' || typeof endIndex !== 'number' || startIndex > endIndex) return;

          const rawBarX = timelineStartX + (startIndex * dayWidth);
          const rawBarWidth = (endIndex - startIndex + 1) * dayWidth;
          const barX = Math.round(rawBarX * 1000) / 1000;
          const barWidth = Math.max(dayWidth, Math.round(rawBarWidth * 1000) / 1000);
          const barHeight = rowHeight * 0.6;
          const barY = topY + ((rowHeight - barHeight) / 2);

          if (barWidth <= 0) return;

          const workingIndices = [];
          for (let index = startIndex; index <= endIndex; index += 1) {
            const day = timelineDays[index];
            if (!isStanddownDay(day)) workingIndices.push(index);
          }

          const segments = buildMiniSegments(task);
          const paintSegments = segments.length ? segments : [{ name: null, duration: workingIndices.length }];
          const paintedRects = [];
          let workingPointer = 0;
          paintSegments.forEach((segment) => {
            const duration = Math.max(0, segment.duration || 0);
            if (duration <= 0) return;
            const startWorkingIndex = workingIndices[workingPointer];
            if (startWorkingIndex == null) return;
            const endWorkingIndex = workingIndices[Math.min(
              workingPointer + duration - 1,
              workingIndices.length - 1
            )];
            if (endWorkingIndex == null || endWorkingIndex < startWorkingIndex) return;
            const left = (startWorkingIndex - startIndex) * dayWidth;
            const width = (endWorkingIndex - startWorkingIndex + 1) * dayWidth;
            const color = segment.name ? parseColorToRgb(getMiniColor(segment.name)) : parseColorToRgb(DEFAULT_SEGMENT_COLOR);
            doc.setFillColor(color.r, color.g, color.b);
            doc.rect(barX + left, barY, width, barHeight, 'F');
            paintedRects.push({ left, width });
            workingPointer += duration;
          });

          if (!paintedRects.length && workingIndices.length && !isStageRow) {
            const left = 0;
            const width = (workingIndices[workingIndices.length - 1] - startIndex + 1) * dayWidth;
            const fallback = parseColorToRgb(DEFAULT_SEGMENT_COLOR);
            doc.setFillColor(fallback.r, fallback.g, fallback.b);
            doc.rect(barX + left, barY, width, barHeight, 'F');
            paintedRects.push({ left, width });
          }

          if (!isStageRow && progressValue > 0 && workingIndices.length) {
            let remaining = (progressValue / 100) * workingIndices.length;
            let prevIndex = null;
            let currentSegment = null;
            const overlaySegments = [];
            for (let i = 0; i < workingIndices.length && remaining > 1e-6; i += 1) {
              const idx = workingIndices[i];
              const left = (idx - startIndex) * dayWidth;
              const portion = Math.min(1, remaining);
              const contiguous = currentSegment && prevIndex != null && idx === prevIndex + 1 && !currentSegment.partial;
              if (!contiguous) {
                currentSegment = { left, width: portion * dayWidth, partial: portion < 1 };
                overlaySegments.push(currentSegment);
              } else {
                currentSegment.width += portion * dayWidth;
                currentSegment.partial = portion < 1;
              }
              remaining -= portion;
              prevIndex = idx;
              if (portion < 1) break;
            }

            overlaySegments.forEach((segment) => {
              const overlayX = barX + segment.left;
              const overlayWidth = Math.min(segment.width, barWidth);
              if (overlayWidth <= 0) return;
              if (progressOverlayState && resetOpacityState) {
                doc.setGState(progressOverlayState);
                doc.setFillColor(255, 255, 255);
                doc.rect(overlayX, barY, overlayWidth, barHeight, 'F');
                doc.setGState(resetOpacityState);
              }
              doc.setFillColor(255, 255, 255);
              const stripeWidth = 0.45;
              const stripeSpacing = 2;
              const stripeRight = overlayX + overlayWidth;
              for (let stripeX = overlayX; stripeX < stripeRight; stripeX += stripeSpacing) {
                const width = Math.min(stripeWidth, stripeRight - stripeX);
                if (width <= 0) continue;
                doc.rect(stripeX, barY, width, barHeight, 'F');
              }
            });
          }

          doc.setDrawColor(80, 94, 120);
          if (isStageRow) {
            doc.setFillColor(stageFill.r, stageFill.g, stageFill.b);
            doc.rect(barX, barY, barWidth, barHeight, 'F');
            doc.setDrawColor(212, 163, 18);
            doc.setLineWidth(0.3);
            doc.rect(barX, barY, barWidth, barHeight);
            doc.setLineWidth(originalLineWidth);
            doc.setDrawColor(defaultDrawColor.r, defaultDrawColor.g, defaultDrawColor.b);
          } else {
            doc.setDrawColor(80, 94, 120);
            paintedRects.forEach((rect) => {
              doc.rect(barX + rect.left, barY, rect.width, barHeight);
            });
            doc.setDrawColor(defaultDrawColor.r, defaultDrawColor.g, defaultDrawColor.b);
          }

          const labelMaxWidth = Math.max(barWidth - 4, 0);
          if (labelMaxWidth > 0) {
            const label = truncateText(task.name, labelMaxWidth);
            if (label) {
              doc.setFont('helvetica', 'bold');
              doc.setFontSize(7);
              doc.setTextColor(33, 45, 67);
              doc.text(label, barX + 2, barY + (barHeight / 2) + 0.2, { baseline: 'middle' });
              doc.setFont('helvetica', 'normal');
              doc.setFontSize(9);
              doc.setTextColor(defaultTextColor.r, defaultTextColor.g, defaultTextColor.b);
            }
          }
        };

        const startNewPage = (isFirstPage) => {
          if (!isFirstPage) {
            doc.addPage();
          }
          doc.setTextColor(defaultTextColor.r, defaultTextColor.g, defaultTextColor.b);
          doc.setDrawColor(defaultDrawColor.r, defaultDrawColor.g, defaultDrawColor.b);
          doc.setLineWidth(0.2);
          let cursorY = drawDocumentHeader(margin);

          doc.setFillColor(headerFill.r, headerFill.g, headerFill.b);
          doc.rect(margin, cursorY, leftColumnWidth, timelineHeaderHeight, 'F');
          doc.rect(margin, cursorY, leftColumnWidth, timelineHeaderHeight);

          doc.setFont('helvetica', 'bold');
          doc.setFontSize(9);
          let headerX = margin;
          const headerBaseline = cursorY + 4;
          columnLabels.forEach((label, index) => {
            doc.text(label, headerX + textPadding, headerBaseline);
            headerX += columnWidths[index];
          });
          doc.setFont('helvetica', 'normal');
          doc.setFontSize(8);
          drawTimelineHeader(cursorY);
          doc.setFont('helvetica', 'normal');
          doc.setFontSize(9);
          return cursorY + timelineHeaderHeight;
        };

        const ensurePageCapacity = (requiredHeight) => {
          if (currentY + requiredHeight > pageBottom) {
            currentY = startNewPage(false);
          }
        };

        let currentY = startNewPage(true);
        tasksSnapshot.forEach((task, index) => {
          const layout = computeRowLayout(task);
          ensurePageCapacity(layout.rowHeight);
          drawTaskRow(task, currentY, index, layout);
          currentY += layout.rowHeight;
        });

        doc.save('project-programme.pdf');
      }

      function updateTaskStartDate(task, newStartDate) {
        if (task?.singleEvent) {
          const start = ensureWeekday(newStartDate, 1);
          const normalized = formatDate(start);
          task.startDate = normalized;
          task.endDate = normalized;
          return;
        }
        const currentEnd = parseDate(task.endDate) || newStartDate;
        let duration = diffInWeekdays(newStartDate, currentEnd);
        const minDuration = minimumTaskDuration(task);
        if (duration < minDuration) {
          const adjustedEnd = shiftWeekdays(newStartDate, minDuration - 1);
          task.endDate = formatDate(adjustedEnd);
          duration = diffInWeekdays(newStartDate, adjustedEnd);
        }
        reconcileMiniDurationsForTask(task, Math.max(1, duration), {
          anchor: 'start',
          referenceStart: newStartDate
        });
      }

      function updateTaskEndDate(task, newEndDate) {
        if (task?.singleEvent) {
          const normalizedStart = formatDate(ensureWeekday(parseDate(task.startDate) || newEndDate, 1));
          task.startDate = normalizedStart;
          task.endDate = normalizedStart;
          return;
        }
        const currentStart = parseDate(task.startDate) || newEndDate;
        let duration = diffInWeekdays(currentStart, newEndDate);
        const minDuration = minimumTaskDuration(task);
        if (duration < minDuration) {
          newEndDate = shiftWeekdays(currentStart, minDuration - 1);
          duration = diffInWeekdays(currentStart, newEndDate);
        }
        reconcileMiniDurationsForTask(task, Math.max(1, duration), {
          anchor: 'end',
          referenceEnd: newEndDate
        });
      }

      function applyNewStartDate(task, newStartDate, fixedEndDate) {
        if (task?.singleEvent) {
          const normalized = formatDate(ensureWeekday(newStartDate, 1));
          task.startDate = normalized;
          task.endDate = normalized;
          return;
        }
        let start = ensureWeekday(newStartDate, 1);
        let end = ensureWeekday(fixedEndDate, -1);
        if (compareDates(end, start) < 0) {
          end = shiftWeekdays(start, minimumTaskDuration(task) - 1);
        }
        const duration = Math.max(minimumTaskDuration(task), diffInWeekdays(start, end));
        end = shiftWeekdays(start, duration - 1);
        reconcileMiniDurationsForTask(task, duration, {
          anchor: 'start',
          referenceStart: start
        });
      }

      function applyNewEndDate(task, fixedStartDate, newEndDate) {
        if (task?.singleEvent) {
          const normalized = formatDate(ensureWeekday(parseDate(task.startDate) || fixedStartDate, 1));
          task.startDate = normalized;
          task.endDate = normalized;
          return;
        }
        let start = ensureWeekday(fixedStartDate, 1);
        let end = ensureWeekday(newEndDate, -1);
        if (compareDates(end, start) < 0) {
          end = shiftWeekdays(start, minimumTaskDuration(task) - 1);
        }
        const duration = Math.max(minimumTaskDuration(task), diffInWeekdays(start, end));
        end = shiftWeekdays(start, duration - 1);
        reconcileMiniDurationsForTask(task, duration, {
          anchor: 'end',
          referenceEnd: end
        });
      }

      function selectTask(taskId) {
        selectedTaskId = taskId;
        renderAll();
      }

      function updateActionButtons() {
        const hasSelection = Boolean(selectedTaskId);
        editTaskBtn.disabled = !hasSelection;
        const currentIndex = hasSelection ? tasks.findIndex((task) => task.id === selectedTaskId) : -1;
        moveUpBtn.disabled = !hasSelection || currentIndex <= 0;
        moveDownBtn.disabled = !hasSelection || currentIndex === -1 || currentIndex >= tasks.length - 1;
        if (removeTaskBtn) removeTaskBtn.disabled = !hasSelection;
      }

      function moveTaskRelative(sourceId, targetId, insertAfter = false) {
        if (!sourceId || !targetId || sourceId === targetId) return;
        const sourceIndex = tasks.findIndex((task) => task.id === sourceId);
        if (sourceIndex === -1) return;
        const [movedTask] = tasks.splice(sourceIndex, 1);
        let targetIndex = tasks.findIndex((task) => task.id === targetId);
        if (targetIndex === -1) {
          tasks.splice(sourceIndex, 0, movedTask);
          return;
        }
        const targetTask = tasks[targetIndex];
        if (movedTask.entryType === 'stage') {
          movedTask.parentId = null;
          let insertIndex = targetIndex;
          if (insertAfter) insertIndex += 1;
          tasks.splice(insertIndex, 0, movedTask);
        } else if (targetTask.entryType === 'stage') {
          movedTask.parentId = targetTask.id;
          const children = getStageChildren(targetTask.id);
          const stageIndex = tasks.findIndex((task) => task.id === targetTask.id);
          let insertIndex;
          if (!children.length) {
            insertIndex = stageIndex + 1;
          } else {
            const lastChild = children[children.length - 1];
            const lastChildIndex = tasks.findIndex((task) => task.id === lastChild.id);
            insertIndex = lastChildIndex + 1;
          }
          tasks.splice(insertIndex, 0, movedTask);
        } else {
          movedTask.parentId = targetTask.parentId || null;
          targetIndex = tasks.findIndex((task) => task.id === targetId);
          let insertIndex = targetIndex;
          if (insertAfter) insertIndex += 1;
          tasks.splice(insertIndex, 0, movedTask);
        }
        draggedTaskId = null;
        selectedTaskId = movedTask.id;
        renderAll();
      }

      function moveSelectedTask(direction) {
        if (!selectedTaskId) return;
        const currentIndex = tasks.findIndex((task) => task.id === selectedTaskId);
        if (currentIndex === -1) return;
        const targetIndex = currentIndex + direction;
        if (targetIndex < 0 || targetIndex >= tasks.length) return;
        const [task] = tasks.splice(currentIndex, 1);
        tasks.splice(targetIndex, 0, task);
        selectedTaskId = task.id;
        renderAll();
      }

      function removeSelectedTask() {
        if (!selectedTaskId) return;
        const index = tasks.findIndex((task) => task.id === selectedTaskId);
        if (index === -1) return;
        const [removedTask] = tasks.splice(index, 1);
        if (removedTask && removedTask.entryType === 'stage') {
          tasks.forEach((task) => {
            if (task.parentId === removedTask.id) task.parentId = null;
          });
        }
        if (tasks.length) {
          const nextIndex = Math.min(index, tasks.length - 1);
          selectedTaskId = tasks[nextIndex].id;
        } else {
          selectedTaskId = null;
        }
        renderAll();
      }

      function createDefaultSequencedMiniTasks(taskId) {
        return DEFAULT_SEQUENCE_STEPS.map((step, index) => ({
          id: `${taskId}-mini-${index + 1}`,
          enabled: true,
          name: step.name,
          duration: step.weight,
          locked: false
        }));
      }

      function renderLegend() {
        if (!legendContainer) return;
        legendContainer.innerHTML = '';
        Object.entries(TASK_COLOR_MAP).forEach(([label, color]) => {
          const item = document.createElement('span');
          item.className = 'legend-item';
          const swatch = document.createElement('span');
          swatch.className = 'legend-swatch';
          swatch.style.background = color;
          item.appendChild(swatch);
          item.appendChild(document.createTextNode(label));
          legendContainer.appendChild(item);
        });
      }

      function populateBuildingTypeOptions() {
        const uniqueTypes = [...new Set(databaseRecords.map((record) => record.buildingType))].filter(Boolean).sort((a, b) => a.localeCompare(b));
        buildingTypeSelect.innerHTML = '';
        if (!uniqueTypes.length) {
          const option = document.createElement('option');
          option.value = '';
          option.textContent = 'No building types found';
          option.disabled = true;
          option.selected = true;
          buildingTypeSelect.appendChild(option);
          return;
        }
        uniqueTypes.forEach((type, index) => {
          const option = document.createElement('option');
          option.value = type;
          option.textContent = type;
          if (index === 0) option.selected = true;
          buildingTypeSelect.appendChild(option);
        });
      }

      async function loadDatabase() {
        databaseRecords = [];
        try {
          const response = await fetch(`database.json?cache-bust=${Date.now()}`, { cache: 'no-store' });
          if (!response.ok) throw new Error(`Request failed: ${response.status}`);
          const data = await response.json();
          if (Array.isArray(data) && data.length) {
            databaseRecords = data;
          }
        } catch (error) {
          console.warn('Unable to load database.json, falling back to embedded data', error);
        }
        if (!databaseRecords.length && window.location.protocol === 'file:') {
          try {
            const module = await import(`./database.json?cache-bust=${Date.now()}`, { assert: { type: 'json' } });
            if (module && Array.isArray(module.default) && module.default.length) {
              databaseRecords = module.default;
            }
          } catch (error) {
            console.warn('Dynamic JSON import failed, using embedded fallback', error);
          }
        }
        if (!databaseRecords.length) {
          databaseRecords = DATABASE_FALLBACK.slice();
        }
        populateBuildingTypeOptions();
      }

      function sanitizeNumber(input, min, max, fallback) {
        let value = Number.parseFloat(input.value);
        if (Number.isNaN(value)) value = fallback;
        value = Math.min(max, Math.max(min, value));
        input.value = value;
        return value;
      }

      function generateScheduleFromConfig() {
        if (!databaseRecords.length) return;
        const buildingType = buildingTypeSelect.value;
        if (!buildingType) return;
        const projectDifficulty = Math.round(sanitizeNumber(projectDifficultyInput, 1, 10, 1));
        const numberOfLevels = Math.round(sanitizeNumber(numberOfLevelsInput, 1, 99, 1));
        const projectSize = Math.round(sanitizeNumber(projectSizeInput, 100, 20000, 100));
        const filtered = databaseRecords.filter((record) => record.buildingType === buildingType);
        const baseStart = ensureWeekday(new Date(), 1);
        if (!filtered.length) {
          tasks = [];
          selectedTaskId = null;
          renderAll();
          return;
        }
        const timestampBase = Date.now();
        const stagePriorityMap = new Map(STAGE_PRESET_OPTIONS.map((option, index) => [option.value, index]));
        const stageGroups = new Map();
        const stageOrderList = [];
        const unassignedRecords = [];
        filtered.forEach((record, index) => {
          const stageLabelRaw = typeof record.Stage === 'string' ? record.Stage.trim() : '';
          if (!stageLabelRaw) {
            unassignedRecords.push({ record, index });
            return;
          }
          const stageKey = stageLabelRaw.toLowerCase();
          if (!stageGroups.has(stageKey)) {
            const preset = mapStagePresetFromLabel(stageLabelRaw);
            stageGroups.set(stageKey, {
              key: stageKey,
              label: stageLabelRaw,
              preset,
              order: stageOrderList.length,
              records: []
            });
            stageOrderList.push(stageKey);
          }
          stageGroups.get(stageKey).records.push({ record, index });
        });

        const orderedStageGroups = Array.from(stageGroups.values()).sort((a, b) => {
          const maxPriority = STAGE_PRESET_OPTIONS.length + 1;
          const priorityA = stagePriorityMap.has(a.preset) ? stagePriorityMap.get(a.preset) : maxPriority;
          const priorityB = stagePriorityMap.has(b.preset) ? stagePriorityMap.get(b.preset) : maxPriority;
          if (priorityA !== priorityB) return priorityA - priorityB;
          return a.order - b.order;
        });

        const generatedTasks = [];
        let stageIndex = 0;
        let taskCounter = 0;
        let previousStageEnd = null;

        orderedStageGroups.forEach((group) => {
          const stageId = `gen-stage-${timestampBase}-${stageIndex}`;
          stageIndex += 1;
          const stageMetadata = normalizeStageMetadata({
            id: stageId,
            name: group.label,
            stagePreset: group.preset,
            stageCustomName: group.preset === 'other' ? group.label : ''
          });
          stageMetadata.description = '';
          stageMetadata.startDate = '';
          stageMetadata.endDate = '';
          stageMetadata.progress = 0;
          generatedTasks.push(stageMetadata);

          const baseStageStart = previousStageEnd
            ? shiftWeekdays(previousStageEnd, 1)
            : ensureWeekday(new Date(baseStart.getTime()), 1);
          let stageEarliest = null;
          let stageLatest = null;

          group.records.forEach(({ record }) => {
            const baseWeekdays = Number(record.weekdays) || 0;
            const sqFactor = Number(record.squareMeterFactor) || 0;
            const diffFactor = Number(record.difficultyFactor) || 0;
            const levelsFactor = Number(record.levelsFactor) || 0;
            const adjusted = baseWeekdays
              + projectSize * sqFactor * baseWeekdays
              + projectDifficulty * diffFactor * baseWeekdays
              + numberOfLevels * levelsFactor * baseWeekdays;
            const totalDuration = Math.max(1, Math.ceil(adjusted));
            const taskStart = new Date(baseStageStart.getTime());
            const taskEnd = shiftWeekdays(taskStart, totalDuration - 1);
            const taskId = `gen-${timestampBase}-${taskCounter}`;
            taskCounter += 1;
            const miniTasks = createDefaultSequencedMiniTasks(taskId);
            const task = {
              id: taskId,
              entryType: 'task',
              parentId: stageId,
              stagePreset: '',
              stageCustomName: '',
              isStage: false,
              name: record.task,
              description: '',
              startDate: formatDate(taskStart),
              endDate: formatDate(taskEnd),
              progress: 0,
              miniTasks,
              undefinedDuration: 0,
              singleEvent: false
            };
            ensureTaskDates(task);
            const normalizedStart = parseDate(task.startDate);
            const normalizedEnd = parseDate(task.endDate);
            if (normalizedStart && (!stageEarliest || compareDates(normalizedStart, stageEarliest) < 0)) {
              stageEarliest = normalizedStart;
            }
            if (normalizedEnd && (!stageLatest || compareDates(normalizedEnd, stageLatest) > 0)) {
              stageLatest = normalizedEnd;
            }
            generatedTasks.push(task);
          });

          if (stageEarliest) stageMetadata.startDate = formatDate(stageEarliest);
          if (stageLatest) stageMetadata.endDate = formatDate(stageLatest);
          previousStageEnd = stageLatest || previousStageEnd;
        });

        const defaultStart = ensureWeekday(new Date(baseStart.getTime()), 1);
        unassignedRecords.forEach(({ record }) => {
          const baseWeekdays = Number(record.weekdays) || 0;
          const sqFactor = Number(record.squareMeterFactor) || 0;
          const diffFactor = Number(record.difficultyFactor) || 0;
          const levelsFactor = Number(record.levelsFactor) || 0;
          const adjusted = baseWeekdays
            + projectSize * sqFactor * baseWeekdays
            + projectDifficulty * diffFactor * baseWeekdays
            + numberOfLevels * levelsFactor * baseWeekdays;
          const totalDuration = Math.max(1, Math.ceil(adjusted));
          const taskStart = new Date(defaultStart.getTime());
          const taskEnd = shiftWeekdays(taskStart, totalDuration - 1);
          const taskId = `gen-${timestampBase}-${taskCounter}`;
          taskCounter += 1;
          const miniTasks = createDefaultSequencedMiniTasks(taskId);
          const task = {
            id: taskId,
            entryType: 'task',
            parentId: null,
            stagePreset: '',
            stageCustomName: '',
            isStage: false,
            name: record.task,
            description: '',
            startDate: formatDate(taskStart),
            endDate: formatDate(taskEnd),
            progress: 0,
            miniTasks,
            undefinedDuration: 0,
            singleEvent: false
          };
          ensureTaskDates(task);
          generatedTasks.push(task);
        });

        tasks = generatedTasks;
        selectedTaskId = tasks.length ? tasks[0].id : null;
        renderAll();
      }

      function renderMiniTaskInputs() {
        if (!miniTaskList) return;
        miniTaskList.innerHTML = '';
        miniTaskDrafts.forEach((mini, index) => {
          const item = document.createElement('div');
          item.className = 'mini-task-item';
          item.dataset.index = String(index);
          if (!mini.enabled) item.classList.add('disabled');
          if (mini.locked) item.classList.add('locked');

          const toggleLabel = document.createElement('label');
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.checked = Boolean(mini.enabled);
          checkbox.addEventListener('change', () => {
            setMiniTaskEnabled(index, checkbox.checked);
          });
          const labelText = document.createElement('span');
          labelText.textContent = String(index + 1);
          toggleLabel.appendChild(checkbox);
          toggleLabel.appendChild(labelText);

          const nameSelect = document.createElement('select');
          nameSelect.disabled = !mini.enabled;
          const placeholderOption = document.createElement('option');
          placeholderOption.value = '';
          placeholderOption.textContent = 'Select description';
          nameSelect.appendChild(placeholderOption);
          MINI_TASK_OPTIONS.forEach((option) => {
            const optionEl = document.createElement('option');
            optionEl.value = option;
            optionEl.textContent = option;
            nameSelect.appendChild(optionEl);
          });
          nameSelect.value = MINI_TASK_OPTIONS.includes(mini.name) ? mini.name : '';
          nameSelect.addEventListener('change', () => {
            setMiniTaskName(index, nameSelect.value);
          });

          const isDelay = mini.enabled && mini.name === 'Delays';
          item.classList.toggle('delay-active', isDelay);

          const durationWrapper = document.createElement('div');
          durationWrapper.className = 'mini-task-duration';
          const durationInput = document.createElement('input');
          durationInput.type = 'number';
          durationInput.min = miniTaskUnit === 'weeks' ? '0.2' : '1';
          durationInput.step = miniTaskUnit === 'weeks' ? '0.5' : '1';
          durationInput.value = String(getDraftDurationInCurrentUnit(mini.duration));
          durationInput.disabled = !mini.enabled;
          const handleDurationChange = () => {
            setMiniTaskDuration(index, parseFloat(durationInput.value));
          };
          durationInput.addEventListener('change', handleDurationChange);
          durationInput.addEventListener('blur', () => {
            handleDurationChange();
            const wrapper = durationInput.closest('.mini-task-item');
            if (wrapper) wrapper.classList.remove('duration-focused');
          });
          durationInput.addEventListener('focus', () => {
            const wrapper = durationInput.closest('.mini-task-item');
            if (wrapper) wrapper.classList.add('duration-focused');
          });
          const durationSuffix = document.createElement('span');
          durationSuffix.textContent = miniTaskUnit === 'weeks' ? 'weeks' : 'days';
          durationWrapper.appendChild(durationInput);
          durationWrapper.appendChild(durationSuffix);

          const delayExtras = document.createElement('div');
          delayExtras.className = 'mini-delay-extras';
          const descriptionInput = document.createElement('textarea');
          descriptionInput.placeholder = 'Delay description';
          descriptionInput.value = mini.delayDescription || '';
          descriptionInput.disabled = !isDelay;
          descriptionInput.addEventListener('input', () => {
            setMiniTaskDelayDescription(index, descriptionInput.value);
            autoResizeTextarea(descriptionInput);
          });
          autoResizeTextarea(descriptionInput);
          const controls = document.createElement('div');
          controls.className = 'mini-task-controls';
          const upButton = document.createElement('button');
          upButton.type = 'button';
          upButton.className = 'mini-move mini-move-up';
          upButton.textContent = '↑';
          upButton.title = 'Move step up';
          upButton.setAttribute('aria-label', `Move step ${index + 1} up`);
          upButton.disabled = index === 0;
          upButton.addEventListener('click', () => moveMiniTaskDraft(index, -1));

          const downButton = document.createElement('button');
          downButton.type = 'button';
          downButton.className = 'mini-move mini-move-down';
          downButton.textContent = '↓';
          downButton.title = 'Move step down';
          downButton.setAttribute('aria-label', `Move step ${index + 1} down`);
          downButton.disabled = index === miniTaskDrafts.length - 1;
          downButton.addEventListener('click', () => moveMiniTaskDraft(index, 1));

          controls.appendChild(upButton);
          controls.appendChild(downButton);

          const chargeLabel = document.createElement('label');
          chargeLabel.className = 'mini-delay-charge';
          const chargeCheckbox = document.createElement('input');
          chargeCheckbox.type = 'checkbox';
          chargeCheckbox.checked = isDelay ? Boolean(mini.chargeToClient) : false;
          chargeCheckbox.disabled = !isDelay;
          chargeCheckbox.addEventListener('change', () => {
            setMiniTaskCharge(index, chargeCheckbox.checked);
          });
          const chargeText = document.createElement('span');
          chargeText.textContent = 'Charge to client';
          chargeLabel.appendChild(chargeCheckbox);
          chargeLabel.appendChild(chargeText);
          delayExtras.appendChild(descriptionInput);
          delayExtras.appendChild(chargeLabel);

          item.appendChild(toggleLabel);
          item.appendChild(nameSelect);
          item.appendChild(durationWrapper);
          item.appendChild(controls);
          item.appendChild(delayExtras);
          miniTaskList.appendChild(item);
        });
        updateMiniTaskToolbar();
      }

      function createMiniTaskDraft(overrides = {}) {
        return sanitizeMiniTaskDraft({
          enabled: false,
          name: '',
          duration: 1,
          locked: false,
          delayDescription: '',
          chargeToClient: false,
          ...overrides
        });
      }

      function sanitizeMiniTaskDraft(draft) {
        const result = {
          enabled: Boolean(draft?.enabled),
          name: typeof draft?.name === 'string' ? draft.name : '',
          duration: Math.max(1, Math.round(Number.isFinite(draft?.duration) ? draft.duration : 1)),
          locked: Boolean(draft?.locked),
          delayDescription: typeof draft?.delayDescription === 'string' ? draft.delayDescription : '',
          chargeToClient: Boolean(draft?.chargeToClient)
        };
        if (result.name !== 'Delays') {
          result.delayDescription = '';
          result.chargeToClient = false;
        }
        return result;
      }

      function getDraftDurationInCurrentUnit(durationDays) {
        const safeDays = Math.max(1, Math.round(Number.isFinite(durationDays) ? durationDays : 1));
        if (miniTaskUnit === 'weeks') {
          return Number((safeDays / WORKING_DAYS_PER_WEEK).toFixed(2));
        }
        return safeDays;
      }

      function setMiniTaskUnit(unit) {
        if (currentEntryType !== 'task') return;
        if (unit !== 'days' && unit !== 'weeks') return;
        if (miniTaskUnit === unit) return;
        miniTaskUnit = unit;
        updateMiniTaskToolbar();
        renderMiniTaskInputs();
        updateDurationPreview();
      }

      function updateMiniTaskToolbar() {
        if (!addMiniTaskBtn || !removeMiniTaskBtn) return;
        const disabled = currentEntryType !== 'task';
        addMiniTaskBtn.disabled = disabled;
        removeMiniTaskBtn.disabled = disabled || miniTaskDrafts.length === 0;
        miniUnitButtons.forEach((button) => {
          const isActive = button.dataset.unit === miniTaskUnit;
          button.classList.toggle('active', isActive);
          button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
          button.disabled = disabled;
          button.setAttribute('aria-disabled', disabled ? 'true' : 'false');
          if (disabled) {
            button.setAttribute('tabindex', '-1');
          } else {
            button.removeAttribute('tabindex');
          }
        });
      }

      function setMiniTaskEnabled(index, enabled) {
        if (!miniTaskDrafts[index]) return;
        if (enabled) {
          miniTaskDrafts[index] = sanitizeMiniTaskDraft({ ...miniTaskDrafts[index], enabled: true });
        } else {
          miniTaskDrafts[index] = sanitizeMiniTaskDraft({ enabled: false, name: '', duration: 1, locked: false, delayDescription: '', chargeToClient: false });
        }
        renderMiniTaskInputs();
        updateDurationPreview();
        if (enabled) focusMiniTask(index, 'name');
      }

      function setMiniTaskName(index, name) {
        if (!miniTaskDrafts[index]) return;
        const isDelay = name === 'Delays';
        miniTaskDrafts[index] = sanitizeMiniTaskDraft({
          ...miniTaskDrafts[index],
          name,
          delayDescription: isDelay ? miniTaskDrafts[index].delayDescription : '',
          chargeToClient: isDelay ? miniTaskDrafts[index].chargeToClient : false
        });
        renderMiniTaskInputs();
        updateDurationPreview();
        focusMiniTask(index, isDelay ? 'delayDescription' : 'name');
      }

      function setMiniTaskDuration(index, value) {
        if (!miniTaskDrafts[index]) return;
        let durationValue = Number(value);
        if (!Number.isFinite(durationValue) || durationValue < 1) durationValue = 1;
        const durationInDays = miniTaskUnit === 'weeks'
          ? durationValue * WORKING_DAYS_PER_WEEK
          : durationValue;
        miniTaskDrafts[index] = sanitizeMiniTaskDraft({ ...miniTaskDrafts[index], duration: durationInDays });
        renderMiniTaskInputs();
        updateDurationPreview();
      }

      function moveMiniTaskDraft(index, direction) {
        const targetIndex = index + direction;
        if (targetIndex < 0 || targetIndex >= miniTaskDrafts.length) return;
        const nextDrafts = [...miniTaskDrafts];
        const [moved] = nextDrafts.splice(index, 1);
        nextDrafts.splice(targetIndex, 0, moved);
        miniTaskDrafts = nextDrafts.map(sanitizeMiniTaskDraft);
        renderMiniTaskInputs();
        updateDurationPreview();
        focusMiniTask(targetIndex, 'name');
      }

      function setMiniTaskDelayDescription(index, value) {
        if (!miniTaskDrafts[index]) return;
        if (miniTaskDrafts[index].name !== 'Delays') {
          miniTaskDrafts[index].delayDescription = '';
          return;
        }
        miniTaskDrafts[index].delayDescription = value;
      }

      function setMiniTaskCharge(index, checked) {
        if (!miniTaskDrafts[index]) return;
        if (miniTaskDrafts[index].name !== 'Delays') {
          miniTaskDrafts[index].chargeToClient = false;
          return;
        }
        miniTaskDrafts[index].chargeToClient = Boolean(checked);
      }

      function focusMiniTask(index, field = 'name') {
        if (!miniTaskList) return;
        requestAnimationFrame(() => {
          let selector = 'select';
          if (field === 'duration') selector = '.mini-task-duration input';
          if (field === 'delayDescription') selector = '.mini-delay-extras textarea';
          const target = miniTaskList.querySelector(`.mini-task-item[data-index="${index}"] ${selector}`);
          if (target) target.focus();
        });
      }

      function addMiniTaskRow(prefill = {}) {
        if (currentEntryType !== 'task') return;
        const prefilled = { ...prefill };
        if (prefilled.duration != null) {
          const raw = Number(prefilled.duration);
          prefilled.duration = Math.max(1, Math.round(raw));
        } else {
          prefilled.duration = miniTaskUnit === 'weeks' ? WORKING_DAYS_PER_WEEK : 1;
        }
        const draft = sanitizeMiniTaskDraft({ enabled: true, ...prefilled });
        miniTaskDrafts = [...miniTaskDrafts, draft];
        renderMiniTaskInputs();
        updateDurationPreview();
        focusMiniTask(miniTaskDrafts.length - 1, 'name');
      }

      function removeMiniTaskRow() {
        if (currentEntryType !== 'task') return;
        if (!miniTaskDrafts.length) return;
        miniTaskDrafts = miniTaskDrafts.slice(0, miniTaskDrafts.length - 1);
        renderMiniTaskInputs();
        updateDurationPreview();
      }

      function updateDurationPreview() {
        if (currentEntryType === 'stage') {
          durationPreview.textContent = 'Stage timeline updates automatically when tasks are added.';
          return;
        }
        let start = ensureWeekday(parseDate(modalStartDate.value), 1);
        if (!start) {
          durationPreview.textContent = '0 working days';
          return;
        }
        if (currentEntryType === 'single') {
          const normalized = formatDate(start);
          if (modalEndDate) modalEndDate.value = normalized;
          durationPreview.textContent = 'Single event (1 working day)';
          return;
        }
        let end = ensureWeekday(parseDate(modalEndDate.value), -1);
        if (!end || compareDates(end, start) < 0) {
          end = new Date(start.getTime());
        }
        let baseDuration = Math.max(1, diffInWeekdays(start, end));
        let miniTotal = 0;
        let enabledCount = 0;
        miniTaskDrafts.forEach((mini) => {
          if (!mini?.enabled) return;
          enabledCount += 1;
          miniTotal += Math.max(1, Math.round(mini.duration || 1));
        });
        if (enabledCount > 0) {
          baseDuration = Math.max(miniTotal, enabledCount);
        }
        const finalEnd = shiftWeekdays(start, baseDuration - 1);
        modalEndDate.value = formatDate(finalEnd);
        durationPreview.textContent = `${baseDuration} working day${baseDuration !== 1 ? 's' : ''}`;
      }

      function openTaskModal(mode = 'create', taskId = null) {
        currentMode = mode;
        editingTaskId = taskId;
        taskForm.reset();
        let task = null;
        if (mode === 'edit' && taskId) {
          task = tasks.find((item) => item.id === taskId) || null;
        }
        if (task) {
          populateModal(task);
          modalTitle.textContent = 'Edit';
          saveTaskBtn.textContent = 'Save';
        } else {
          populateModal();
          modalTitle.textContent = 'New';
          saveTaskBtn.textContent = 'Create';
        }
        document.body.classList.add('modal-open');
        modalBackdrop.classList.remove('hidden');
        modalEl.classList.remove('hidden');
        requestAnimationFrame(() => {
          if (currentEntryType === 'stage' && modalStagePreset) {
            modalStagePreset.focus();
          } else if (modalTaskName && currentEntryType !== 'stage') {
            modalTaskName.focus();
          }
        });
      }

      function closeTaskModal() {
        document.body.classList.remove('modal-open');
        modalBackdrop.classList.add('hidden');
        modalEl.classList.add('hidden');
        editingTaskId = null;
        currentMode = 'create';
        miniTaskDrafts = [];
        miniTaskUnit = 'days';
        setEntryType('task', { skipPreview: true });
        if (modalTaskName) modalTaskName.value = '';
        if (modalTaskDescription) modalTaskDescription.value = '';
        if (modalStageCustomName) modalStageCustomName.value = '';
        updateMiniTaskToolbar();
        updateDurationPreview();
      }

      function populateModal(task = null) {
        const defaultStart = ensureWeekday(new Date(), 1);
        miniTaskUnit = 'days';
        let entryType = 'task';
        if (task) {
          if (task.entryType === 'stage') entryType = 'stage';
          else if (task.entryType === 'single' || task.singleEvent) entryType = 'single';
        }
        if (modalStagePreset && !modalStagePreset.options.length) {
          populateStagePresetOptions();
        }
        setEntryType(entryType, { skipPreview: true });

        if (entryType === 'task') {
          if (task) {
            const baseMini = Array.isArray(task.miniTasks) ? task.miniTasks : [];
            miniTaskDrafts = baseMini.map((mini) => sanitizeMiniTaskDraft(mini));
            const pendingUndefinedDuration = Math.max(0, Math.round(task.undefinedDuration || 0));
            const hasExplicitUndefined = miniTaskDrafts.some((mini) => mini.enabled && mini.name === 'Undefined');
            if (pendingUndefinedDuration > 0 && !hasExplicitUndefined) {
              miniTaskDrafts.push(sanitizeMiniTaskDraft({
                enabled: true,
                name: 'Undefined',
                duration: pendingUndefinedDuration,
                locked: false
              }));
            }
          } else {
            miniTaskDrafts = DEFAULT_SEQUENCE_STEPS.map((step) => sanitizeMiniTaskDraft({
              enabled: true,
              name: step.name,
              duration: step.weight,
              locked: false
            }));
          }
          if (!miniTaskDrafts.length) {
            miniTaskDrafts = [sanitizeMiniTaskDraft(createMiniTaskDraft({ enabled: true }))];
          }
          modalTaskName.value = task ? task.name || '' : '';
          modalTaskDescription.value = task ? task.description || '' : '';
          modalProgress.value = task ? Math.min(100, Math.max(0, Number(task.progress) || 0)) : 0;
          modalStartDate.value = task ? task.startDate || formatDate(defaultStart) : formatDate(defaultStart);
          modalEndDate.value = task ? task.endDate || formatDate(defaultStart) : formatDate(defaultStart);
        } else if (entryType === 'single') {
          miniTaskDrafts = [];
          modalTaskName.value = task ? task.name || '' : '';
          modalTaskDescription.value = task ? task.description || '' : '';
          const singleDate = task ? task.startDate || formatDate(defaultStart) : formatDate(defaultStart);
          modalStartDate.value = singleDate;
          if (modalEndDate) modalEndDate.value = singleDate;
          modalProgress.value = task ? Math.min(100, Math.max(0, Number(task.progress) || 0)) : 0;
        } else {
          // stage
          miniTaskDrafts = [];
          modalTaskName.value = '';
          modalTaskDescription.value = '';
          const stageMeta = task ? normalizeStageMetadata(task) : normalizeStageMetadata();
          modalProgress.value = task ? Math.min(100, Math.max(0, Number(task.progress) || 0)) : 0;
          modalStartDate.value = '';
          if (modalEndDate) modalEndDate.value = '';
          const presetValue = stageMeta.stagePreset;
          if (modalStagePreset) {
            modalStagePreset.value = presetValue;
          }
          if (modalStageCustomName) {
            if (presetValue === 'other') {
              modalStageCustomName.value = stageMeta.stageCustomName || '';
            } else {
              modalStageCustomName.value = '';
            }
          }
          setEntryType('stage', { skipPreview: true });
        }

        renderMiniTaskInputs();
        updateMiniTaskToolbar();
        updateDurationPreview();
      }

      function collectMiniTasks(taskId) {
        if (currentEntryType !== 'task') return [];
        return miniTaskDrafts.map((mini, index) => ({
          id: `${taskId || 'new'}-mini-${index + 1}`,
          enabled: Boolean(mini.enabled),
          name: typeof mini.name === 'string' ? mini.name : '',
          duration: Math.max(1, Math.round(mini.duration || 1)),
          locked: Boolean(mini.locked && mini.enabled),
          delayDescription: (mini.delayDescription || '').trim(),
          chargeToClient: Boolean(mini.chargeToClient)
        }));
      }

      function gatherDelayRows() {
        const rows = [];
        tasks.forEach((task) => {
          if (task.singleEvent) return;
          (task.miniTasks || []).forEach((mini) => {
            if (!mini || !mini.enabled || mini.name !== 'Delays') return;
            const durationDays = Math.max(1, Math.round(mini.duration || 1));
            rows.push({
              taskId: task.id,
              taskName: task.name,
              miniId: mini.id,
              description: mini.delayDescription || '',
              durationDays,
              chargeToClient: Boolean(mini.chargeToClient)
            });
          });
        });
        return rows;
      }

      function updateDelayMiniTask(taskId, miniId, updater) {
        if (typeof updater !== 'function') return;
        const task = tasks.find((item) => item.id === taskId);
        if (!task || !Array.isArray(task.miniTasks)) return;
        const mini = task.miniTasks.find((entry) => entry.id === miniId);
        if (!mini) return;
        updater(mini);
        refreshDelayTooltip(task, mini);
      }

      function refreshDelayTooltip(task, mini) {
        if (!mini || mini.name !== 'Delays') return;
        const durationDays = Math.max(1, Math.round(mini.duration || 1));
        const fallbackTitle = `${mini.name || 'Step'} • ${durationDays} day${durationDays !== 1 ? 's' : ''}`;
        const description = typeof mini.delayDescription === 'string'
          ? mini.delayDescription.trim()
          : '';
        const title = description || fallbackTitle;
        const elements = document.querySelectorAll('.mini-segment');
        elements.forEach((element) => {
          if (element instanceof HTMLElement) {
            if ((element.dataset.segmentId || '') === (mini.id || '')) {
              element.title = title;
            }
          }
        });
      }

      function renderDelaySchedule() {
        if (!delayTableBody) return;
        const rows = gatherDelayRows();
        delayTableBody.innerHTML = '';
        if (!rows.length) {
          const emptyRow = document.createElement('tr');
          const emptyCell = document.createElement('td');
          emptyCell.colSpan = 4;
          emptyCell.className = 'delay-table-empty';
          emptyCell.textContent = 'No recorded delays.';
          emptyRow.appendChild(emptyCell);
          delayTableBody.appendChild(emptyRow);
          return;
        }
        rows.forEach((row, index) => {
          const tr = document.createElement('tr');
          const taskCell = document.createElement('td');
          taskCell.textContent = row.taskName || '--';

          const descriptionCell = document.createElement('td');
          const descInput = document.createElement('textarea');
          descInput.value = row.description;
          descInput.placeholder = 'Describe delay';
          descInput.setAttribute('aria-label', `Delay description for ${row.taskName || 'task'}`);
          descInput.addEventListener('input', () => {
            updateDelayMiniTask(row.taskId, row.miniId, (mini) => {
              mini.delayDescription = descInput.value;
            });
            autoResizeTextarea(descInput);
          });
          autoResizeTextarea(descInput);
          descriptionCell.appendChild(descInput);

          const durationCell = document.createElement('td');
          durationCell.textContent = `${row.durationDays} day${row.durationDays !== 1 ? 's' : ''}`;

          const chargeCell = document.createElement('td');
          chargeCell.className = 'delay-charge-cell';
          const chargeWrapper = document.createElement('div');
          chargeWrapper.className = 'delay-charge-wrapper';
          const chargeCheckbox = document.createElement('input');
          chargeCheckbox.type = 'checkbox';
          chargeCheckbox.checked = row.chargeToClient;
          chargeCheckbox.setAttribute('aria-label', `Charge delay ${index + 1} to client`);
          chargeCheckbox.addEventListener('change', () => {
            updateDelayMiniTask(row.taskId, row.miniId, (mini) => {
              mini.chargeToClient = chargeCheckbox.checked;
            });
          });
          chargeWrapper.appendChild(chargeCheckbox);
          chargeCell.appendChild(chargeWrapper);

          tr.appendChild(taskCell);
          tr.appendChild(descriptionCell);
          tr.appendChild(durationCell);
          tr.appendChild(chargeCell);
          delayTableBody.appendChild(tr);
        });
      }

      function openDelayModal() {
        if (!delayModal || !delayModalBackdrop) return;
        renderDelaySchedule();
        delayModal.classList.remove('hidden');
        delayModalBackdrop.classList.remove('hidden');
      }

      function closeDelayModal() {
        if (!delayModal || !delayModalBackdrop) return;
        delayModal.classList.add('hidden');
        delayModalBackdrop.classList.add('hidden');
      }
      function handleFormSubmit(event) {
        event.preventDefault();
        const rawEntryType = modalEntryType ? modalEntryType.value : 'task';
        const entryType = ['task', 'single', 'stage'].includes(rawEntryType) ? rawEntryType : 'task';
        const isStage = entryType === 'stage';
        const isSingle = entryType === 'single';
        const existingIndex = currentMode === 'edit' && editingTaskId
          ? tasks.findIndex((task) => task.id === editingTaskId)
          : -1;
        const existingTask = existingIndex !== -1 ? tasks[existingIndex] : null;
        const taskId = existingTask ? existingTask.id : `task-${Date.now()}`;
        const existingParentId = existingTask && typeof existingTask.parentId === 'string'
          ? (existingTask.parentId.trim() || null)
          : null;

        let payload = {
          id: taskId,
          entryType,
          parentId: isStage ? null : existingParentId,
          stagePreset: '',
          stageCustomName: '',
          isStage
        };

        if (isStage) {
          if (modalStagePreset && !modalStagePreset.options.length) {
            populateStagePresetOptions();
          }
          const presetValue = modalStagePreset
            ? (modalStagePreset.value || STAGE_PRESET_OPTIONS[0].value)
            : STAGE_PRESET_OPTIONS[0].value;
          const customNameInput = modalStageCustomName ? modalStageCustomName.value.trim() : '';
          const customName = presetValue === 'other' ? customNameInput : '';
          const stageName = presetValue === 'other'
            ? (customName || 'Stage')
            : stageOptionLabel(presetValue);
          const stageMetadata = normalizeStageMetadata({
            id: taskId,
            parentId: null,
            name: stageName,
            stagePreset: presetValue,
            stageCustomName: customName,
            entryType: 'stage'
          });
          payload = {
            ...payload,
            ...stageMetadata,
            description: '',
            startDate: existingTask?.startDate || '',
            endDate: existingTask?.endDate || '',
            progress: existingTask ? Math.min(100, Math.max(0, Number(existingTask.progress) || 0)) : 0,
            miniTasks: [],
            undefinedDuration: 0,
            singleEvent: false
          };
        } else {
          let start = ensureWeekday(parseDate(modalStartDate.value), 1);
          if (!start) start = ensureWeekday(new Date(), 1);
          let end = ensureWeekday(parseDate(modalEndDate.value), -1);
          if (!end || compareDates(end, start) < 0) end = new Date(start.getTime());
          let progress = parseInt(modalProgress.value, 10);
          if (Number.isNaN(progress)) progress = 0;
          progress = Math.min(100, Math.max(0, progress));
          let miniTasks = [];
          let adjustedUndefinedDuration = 0;
          let totalDuration = Math.max(1, diffInWeekdays(start, end));

          if (isSingle) {
            end = new Date(start.getTime());
            totalDuration = 1;
          } else {
            miniTasks = collectMiniTasks(taskId);
            const enabledCount = miniTasks.filter((mini) => mini.enabled).length;
            if (enabledCount > 0) {
              let miniSum = 0;
              miniTasks.forEach((mini) => {
                if (mini.enabled) miniSum += mini.duration;
              });
              totalDuration = Math.max(miniSum, enabledCount);
              end = shiftWeekdays(start, totalDuration - 1);
            }
            ({ undefinedDuration: adjustedUndefinedDuration } = normalizeMiniDurations(miniTasks, totalDuration, {
              undefinedDuration: 0
            }));
          }

          payload = {
            ...payload,
            parentId: existingParentId,
            stagePreset: '',
            stageCustomName: '',
            isStage: false,
            name: modalTaskName.value.trim() || (isSingle ? 'Untitled event' : 'Untitled task'),
            description: modalTaskDescription.value.trim(),
            startDate: formatDate(start),
            endDate: formatDate(end),
            progress,
            miniTasks,
            undefinedDuration: adjustedUndefinedDuration,
            singleEvent: isSingle
          };
          ensureTaskDates(payload);
        }

        if (existingIndex !== -1) {
          const preserved = tasks[existingIndex];
          tasks[existingIndex] = {
            ...preserved,
            ...payload,
            parentId: payload.parentId
          };
          selectedTaskId = tasks[existingIndex].id;
        } else {
          tasks.push(payload);
          selectedTaskId = taskId;
        }
        closeTaskModal();
        renderAll();
      }

      function updateStickyMetrics() {
        const topOffset = topBarEl ? topBarEl.getBoundingClientRect().height : 0;
        document.documentElement.style.setProperty('--top-offset', `${topOffset}px`);
        updateHeaderOffset();

        const sidebarHeaderEl = document.querySelector('.sidebar-header');
        const sidebarHeaderHeight = sidebarHeaderEl ? sidebarHeaderEl.getBoundingClientRect().height : 0;
        document.documentElement.style.setProperty('--sidebar-header-height', `${sidebarHeaderHeight}px`);

        const ganttHeaderEl = document.querySelector('.gantt-header');
        const ganttHeaderHeight = ganttHeaderEl ? ganttHeaderEl.getBoundingClientRect().height : 0;
        document.documentElement.style.setProperty('--gantt-header-height', `${ganttHeaderHeight}px`);

        const rootStyles = getComputedStyle(document.documentElement);
        const rootFontSize = parseFloat(rootStyles.fontSize) || 16;
        const toPixels = (raw) => {
          if (!raw) return 0;
          const trimmed = raw.trim();
          if (trimmed.endsWith('rem')) return parseFloat(trimmed) * rootFontSize;
          if (trimmed.endsWith('px')) return parseFloat(trimmed);
          return parseFloat(trimmed) || 0;
        };

        const taskHeaderHeightPx = toPixels(rootStyles.getPropertyValue('--task-header-height'));
        const timelineHeaderHeightPx = toPixels(rootStyles.getPropertyValue('--timeline-header-height'));
        const contentOffsetPx = toPixels(rootStyles.getPropertyValue('--content-offset'));
        const verticalheaderoffset = toPixels(rootStyles.getPropertyValue('--vertical-header-offset'));
        const bodyoffset = toPixels(rootStyles.getPropertyValue('--body-offset'));

        const taskHeaderTopPx = Math.max(0, topOffset + contentOffsetPx - verticalheaderoffset);
        const timelineHeaderTopPx = Math.max(0, topOffset + contentOffsetPx - verticalheaderoffset);
        const rowHeight = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--row-height')) || 54;

        document.documentElement.style.setProperty('--task-header-top', `${taskHeaderTopPx}px`);
        document.documentElement.style.setProperty('--timeline-header-top', `${timelineHeaderTopPx}px`);

        const taskScrollStartPx = taskHeaderTopPx + taskHeaderHeightPx + bodyoffset;
        const ganttScrollStartPx = timelineHeaderTopPx + timelineHeaderHeightPx + bodyoffset;

        const availableTaskHeight = Math.max(120, window.innerHeight - (ganttScrollStartPx + ganttHeaderHeight));
        const availableGanttHeight = Math.max(120, window.innerHeight - (ganttScrollStartPx + ganttHeaderHeight));
        const unifiedScrollHeight = Math.floor(Math.max(availableTaskHeight, availableGanttHeight) - rowHeight - rowHeight - rowHeight);

        document.documentElement.style.setProperty('--task-scroll-height', `${unifiedScrollHeight}px`);
        document.documentElement.style.setProperty('--gantt-scroll-height', `${unifiedScrollHeight}px`);

      }
      window.addEventListener('resize', () => {
        updateStickyMetrics();
      }, { passive: true });

      function performRenderCycle() {
        renderFrameHandle = null;
        updateAllStageSummaries();
        renderTaskList();
        renderGantt();
        updateActionButtons();
        adjustGanttOffset();
        if (delayModal && !delayModal.classList.contains('hidden')) {
          renderDelaySchedule();
        }
        updateStickyMetrics();
      }

      function renderAllImmediate() {
        if (renderFrameHandle !== null) {
          cancelAnimationFrame(renderFrameHandle);
          renderFrameHandle = null;
        }
        performRenderCycle();
      }

      function renderAll() {
        if (renderFrameHandle !== null) return;
        renderFrameHandle = requestAnimationFrame(performRenderCycle);
      }

      function syncScrollPositions(source, target) {
        if (!source || !target) return;
        if (isSyncingScroll) return;
        isSyncingScroll = true;
        target.scrollTop = source.scrollTop;
        requestAnimationFrame(() => {
          isSyncingScroll = false;
        });
      }

      let timelineHorizontalSyncFrame = null;

      function updateTimelineHorizontalOffset() {
        if (!timelineHeaderEl) return;
        const offset = ganttBodyScrollEl ? Number(ganttBodyScrollEl.scrollLeft) || 0 : 0;
        // Mirror the gantt body horizontal scroll so the header stays aligned.
        if (Math.abs(offset) < 0.5) {
          timelineHeaderEl.style.transform = '';
        } else {
          timelineHeaderEl.style.transform = `translateX(${-offset}px)`;
        }
      }

      function scheduleTimelineHorizontalSync() {
        if (timelineHorizontalSyncFrame !== null) return;
        timelineHorizontalSyncFrame = requestAnimationFrame(() => {
          timelineHorizontalSyncFrame = null;
          updateTimelineHorizontalOffset();
        });
      }

      function attachEventListeners() {
        miniUnitButtons.forEach((button) => {
          button.addEventListener('click', () => {
            setMiniTaskUnit(button.dataset.unit || 'days');
          });
        });
        if (generateScheduleBtn) {
          generateScheduleBtn.addEventListener('click', () => {
            openGenerateModal();
          });
        }
        if (generateCancelBtn) {
          generateCancelBtn.addEventListener('click', () => {
            closeGenerateModal();
          });
        }
        if (generateModalBackdrop) {
          generateModalBackdrop.addEventListener('click', () => {
            closeGenerateModal();
          });
        }
        if (generateForm) {
          generateForm.addEventListener('submit', (event) => {
            event.preventDefault();
            generateScheduleFromConfig();
            closeGenerateModal();
          });
        }
        if (zoomInBtn) {
          zoomInBtn.addEventListener('click', () => adjustZoom(ZOOM_STEP));
        }
        if (zoomOutBtn) {
          zoomOutBtn.addEventListener('click', () => adjustZoom(-ZOOM_STEP));
        }
        if (addMiniTaskBtn) {
          addMiniTaskBtn.addEventListener('click', () => addMiniTaskRow());
        }
        if (removeMiniTaskBtn) {
          removeMiniTaskBtn.addEventListener('click', () => removeMiniTaskRow());
        }
        if (modalEntryType) {
          modalEntryType.addEventListener('change', () => {
            setEntryType(modalEntryType.value);
          });
        }
        if (taskListScrollEl && ganttBodyScrollEl) {
          taskListScrollEl.addEventListener('scroll', () => {
            syncScrollPositions(taskListScrollEl, ganttBodyScrollEl);
          }, { passive: true });
          ganttBodyScrollEl.addEventListener('scroll', () => {
            syncScrollPositions(ganttBodyScrollEl, taskListScrollEl);
            scheduleTimelineHorizontalSync();
          }, { passive: true });
        } else if (ganttBodyScrollEl) {
          ganttBodyScrollEl.addEventListener('scroll', scheduleTimelineHorizontalSync, { passive: true });
        }
        if (plannerViewportEl) {
          plannerViewportEl.addEventListener('scroll', scheduleTimelineHorizontalSync, { passive: true });
        }
        if (modalStagePreset) {
          modalStagePreset.addEventListener('change', () => {
            if (currentEntryType === 'stage') {
              setEntryType('stage');
            }
          });
        }
        if (savePdfBtn) {
          savePdfBtn.addEventListener('click', handleSavePdf);
        }
        if (scheduleSettingsBtn) {
          scheduleSettingsBtn.addEventListener('click', () => {
            openScheduleModal();
          });
        }
        if (addMilestoneBtn) {
          addMilestoneBtn.addEventListener('click', () => {
            const milestone = createMilestone();
            milestoneDrafts.push(milestone);
            selectedMilestoneId = milestone.id;
            renderMilestoneDrafts();
          });
        }
        if (removeMilestoneBtn) {
          removeMilestoneBtn.addEventListener('click', () => {
            if (!selectedMilestoneId) return;
            const index = milestoneDrafts.findIndex((milestone) => milestone.id === selectedMilestoneId);
            if (index !== -1) {
              milestoneDrafts.splice(index, 1);
              selectedMilestoneId = milestoneDrafts[index]?.id || milestoneDrafts[index - 1]?.id || null;
              renderMilestoneDrafts();
            }
          });
        }
        if (scheduleModalBackdrop) {
          scheduleModalBackdrop.addEventListener('click', () => {
            closeScheduleModal();
          });
        }
        if (cancelScheduleBtn) {
          cancelScheduleBtn.addEventListener('click', () => {
            closeScheduleModal();
          });
        }
        if (saveScheduleBtn) {
          saveScheduleBtn.addEventListener('click', handleSaveScheduleSettings);
        }
        if (saveProgrammeBtn) {
          saveProgrammeBtn.addEventListener('click', handleSaveProgramme);
        }
        if (loadProgrammeBtn) {
          loadProgrammeBtn.addEventListener('click', handleLoadProgramme);
        }
        if (delayScheduleBtn) {
          delayScheduleBtn.addEventListener('click', () => openDelayModal());
        }
        if (delayModalBackdrop) {
          delayModalBackdrop.addEventListener('click', () => closeDelayModal());
        }
        if (closeDelayModalBtn) {
          closeDelayModalBtn.addEventListener('click', () => closeDelayModal());
        }
        if (graphAuthBtn) {
          graphAuthBtn.addEventListener('click', handleGraphAuthBtnClick);
        }
        document.addEventListener('keydown', (event) => {
          if (event.key === 'Escape') {
            if (scheduleModal && !scheduleModal.classList.contains('hidden')) {
              event.preventDefault();
              closeScheduleModal();
              return;
            }
            if (generateModal && !generateModal.classList.contains('hidden')) {
              event.preventDefault();
              closeGenerateModal();
              return;
            }
            if (delayModal && !delayModal.classList.contains('hidden')) {
              event.preventDefault();
              closeDelayModal();
            }
          }
        });
        addTaskBtn.addEventListener('click', () => openTaskModal('create'));
        if (removeTaskBtn) {
          removeTaskBtn.addEventListener('click', () => removeSelectedTask());
        }
        editTaskBtn.addEventListener('click', () => {
          if (!selectedTaskId) return;
          openTaskModal('edit', selectedTaskId);
        });
        moveUpBtn.addEventListener('click', () => moveSelectedTask(-1));
        moveDownBtn.addEventListener('click', () => moveSelectedTask(1));
        modalBackdrop.addEventListener('click', closeTaskModal);
        cancelModalBtn.addEventListener('click', closeTaskModal);
        taskForm.addEventListener('submit', handleFormSubmit);
        viewModeButtons.forEach((button) => {
          button.addEventListener('click', () => {
            setTimelineViewMode(button.dataset.viewMode);
          });
        });

        modalStartDate.addEventListener('change', () => {
          modalStartDate.value = formatDate(ensureWeekday(parseDate(modalStartDate.value), 1));
          updateDurationPreview();
        });
        modalEndDate.addEventListener('change', () => {
          modalEndDate.value = formatDate(ensureWeekday(parseDate(modalEndDate.value), -1));
          updateDurationPreview();
        });
        modalProgress.addEventListener('input', () => {
          let value = parseInt(modalProgress.value, 10);
          if (Number.isNaN(value)) value = 0;
          modalProgress.value = Math.min(100, Math.max(0, value));
        });
      }

      function initialise() {
        updateStickyMetrics();
        updateGraphAuthUI();
        ensureMsalClient().then(() => {
          updateGraphAuthUI();
        }).catch((error) => {
          console.warn('Unable to initialise Microsoft authentication on startup.', error);
        });
        renderMiniTaskInputs();
        updateMiniTaskToolbar();
        attachEventListeners();
        renderLegend();
        updateViewModeButtons();
        recomputeStanddownSet();
        renderAllImmediate();
        loadDatabase().then(() => {
          const firstEnabled = Array.from(buildingTypeSelect.options || []).find((option) => !option.disabled);
          if (firstEnabled) {
            buildingTypeSelect.value = firstEnabled.value;
            generateScheduleFromConfig();
          } else {
            tasks = [];
            selectedTaskId = null;
            renderAllImmediate();
          }
        });
      }

      if (isTeamsAuthWindow) {
        await handleTeamsAuthPopupFlow();
        return;
      }

      document.addEventListener('DOMContentLoaded', initialise);
    }());
  </script>
</body>
</html>
